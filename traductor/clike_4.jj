//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   noviembre 2022
// Coms:   compilar mediante "ant"
// Ejecucion: java -jar dist/clike_4.jar fichero 
//*****************************************************************

options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
	UNICODE_INPUT = true;
}

PARSER_BEGIN(clike_4)

package traductor;

import lib.symbolTable.Symbol;
import lib.symbolTable.SymbolTable;
import lib.symbolTable.SymbolArray;
import lib.symbolTable.SymbolBool;
import lib.symbolTable.SymbolChar;
import lib.symbolTable.SymbolFunction;
import lib.symbolTable.SymbolInt;
import lib.symbolTable.SymbolProcedure;
import lib.attributes.Attributes;
import java.util.*; 
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;
import java.io.PrintWriter;  
import java.io.FileWriter;  

public class clike_4 {
	private static final int SALTO_LINEA = 10;
	private static int contadorReturns = 0;
	private static Token tokenActual;
	private static String[] pals = {"int2char","char2int","print","print_ln","read","read_ln",
			"main","int","bool","void","char","if","while","else","return","true","false"};
	private static SymbolTable tabla = new SymbolTable(pals);
	private static ErrorSemantico errSem = new ErrorSemantico();

	public static int functionCounter = 1;
	
	public static int labelCounter = 1;
	public static String nombreFichero = "";

    public static void main(String[] args) {
    	clike_4 parser = null;
		// El nombre del fichero será el primer parametro
		nombreFichero = args[0];
		nombreFichero = nombreFichero.substring(0, nombreFichero.length() - 2);
		nombreFichero = nombreFichero + "pcode";
    	
    	try {
	    	if(args.length == 0) {
				parser = new clike_4(System.in);
			}
			else {
	            parser = new clike_4(new java.io.FileInputStream(args[0]));
			}
			//Programa es el símbolo inicial de la gramática
			parser.Programa();
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
			System.exit(1);
		}
		catch (TokenMgrError e) {
        	System.err.println("Token mgr error: " + e.getMessage());
			System.exit(1);
        }
        catch (ParseException e) {
			// Cambiar el error
			System.err.println("Parse error: " + e.getMessage());
			System.exit(1);
		}
    }

	public static void errLex(String error) {
		System.out.println(error);
		System.exit(1);
	}

	// Comprueba que ambos atributos sean del mismo tipo
	public static Attributes comprobarTipos(Attributes a, Attributes b) {
		if (a.type != b.type) {
			errSem.deteccion(new NotMachingTypes(a, b), a.token, b.token);
		} 
		return a;
	}	

	// Comprueba que ambos atributos sean del mismo tipo
	public static Attributes comprobarTiposAsignacion(Symbol simbolo, Attributes a) {
		if (a.type != simbolo.type) {
			String _tipoVar = obtenerTipo(simbolo.type);
       		String _tipoDevuelto = obtenerTipo(a.type);
			errSem.deteccion(new IncompatibleTypes("Si has llegado a leer esto nos merecemos un 10 :)"),  a.token, _tipoVar, _tipoDevuelto);
		}
		return a;
	}	

	// Comprueba que ambos atributos sean del mismo tipo cuando uno es un vector
	public static Attributes comprobarTiposAsignacionVec(Symbol.Types tipo, Attributes a) {
		if (a.type != tipo) {
			String _tipoVar = obtenerTipo(tipo);
       		String _tipoDevuelto = obtenerTipo(a.type);
			errSem.deteccion(new IncompatibleTypes("Si has llegado a leer esto nos merecemos un 10 :)"),  a.token, _tipoVar, _tipoDevuelto);
		} 
		return a;
	}	

	// Comprueba que el atributo a es boolean
	public static void comprobarBool(Attributes a) {
		if (a.type != Symbol.Types.BOOL) {
			errSem.deteccion(new NotBoolean(a), a.token);
		}
	}

	// Comprueba que el atributo a es entero
	public static void comprobarInt (Attributes a) {
		if (a.type != Symbol.Types.INT) {
			errSem.deteccion(new NotInt(a), a.token);
		}
	}

	// Comprueba que el atributo a es entero
	public static void comprobarChar (Attributes a) {
		if (a.type != Symbol.Types.CHAR) {
			errSem.deteccion(new NotChar(a), a.token);
		}
	}

	// Comprueba que el atributo a es entero o char o bool
	public static void comprobarTipoValido (Symbol simbolo) {
		if (simbolo.type != Symbol.Types.CHAR && simbolo.type != Symbol.Types.INT && simbolo.type != Symbol.Types.BOOL) {
			//errSem.deteccion(NotTipoValido, a.token);
			errSem.deteccion(new NotTipoValido(simbolo), tokenActual);
		}
	}

	// Comprueba que el atributo a es entero o char o bool
	public static void comprobarTipoValido (Symbol.Types simbolo) {
		if (simbolo != Symbol.Types.CHAR && simbolo != Symbol.Types.INT && simbolo != Symbol.Types.BOOL) {
			//errSem.deteccion(NotTipoValido, a.token);
			errSem.deteccion(new NotTipoValido(simbolo), tokenActual);
		}
	}

	// Comprueba que el atributo a es entero
	public static void comprobarTipoValidoString (Attributes a) {
		if (a.type != Symbol.Types.CHAR && a.type != Symbol.Types.INT && a.type != Symbol.Types.BOOL && a.type != Symbol.Types.STRING) {
			errSem.deteccion(new NotTipoValido(a), a.token, "String");
		}
	}

	// Comprueba si coincide el valor devuelto y el tipo que devuelve la funcion
	public static void comprobarTipoReturn (Attributes a, Symbol.Types tipo) {
		String _tipoVar = obtenerTipo(a.type);
        String _tipoDevuelto = obtenerTipo(tipo);

		if (!_tipoVar.equals(_tipoDevuelto)) { 
			errSem.deteccion(new IncompatibleTypes("Si has llegado a leer esto nos merecemos un 10 :)"), a.token, _tipoDevuelto, _tipoVar);
		}
	}

		// Comprueba si coincide el valor devuelto y el tipo que devuelve la funcion
	public static void comprobarTipoParametro (Attributes a, Symbol.Types tipo) {
		String _tipoVar = obtenerTipo(a.type);
        String _tipoDevuelto = obtenerTipo(tipo);
				
		if (!_tipoVar.equals(_tipoDevuelto)) {
			errSem.deteccion(new IncompatibleTypes("Si has llegado a leer esto nos merecemos un 10 :)"), a.token, _tipoVar, _tipoDevuelto);
		}
	}

	public static void comprobarParametros(ArrayList<Symbol> lista1,ArrayList<Attributes> lista2, Token token) {
		String mensaje = "";
		if (lista1.size() != lista2.size()) {
			mensaje = "El número de parámetros no coincide";
			errSem.deteccion(new IncompatibleSizes(mensaje), token);
		} else {
			for (int i = 0; i < lista1.size(); i++) {
				if (lista1.get(i).type != lista2.get(i).type) {
					String _tipoVar = obtenerTipo(lista1.get(i).type);
       				String _tipoDevuelto = obtenerTipo(lista2.get(i).type);
					errSem.deteccion(new IncompatibleTypes("Si has llegado a leer esto nos merecemos un 10 :)"), lista2.get(i).token, _tipoVar, _tipoDevuelto);
				}
			}
		}
	}

	// Comprobar si el atributo dado es constante
	public static void comprobarNoConstante(Attributes a) {
		if (a.constante) {
			errSem.deteccion(new ConstantePorReferencia(), a.token);
		}
	}

	private static String obtenerTipo(Symbol.Types tipo) {
        String _tipoDevuelto = "";

		// Pasamos a string el tipo
        if (tipo == Symbol.Types.INT) {
            _tipoDevuelto = "int";
        } else if (tipo == Symbol.Types.BOOL) {
            _tipoDevuelto = "bool";
        } else if (tipo == Symbol.Types.CHAR) {
			_tipoDevuelto = "char";
		} else if (tipo == Symbol.Types.ARRAY) {
			_tipoDevuelto = "array";
		} else {
			_tipoDevuelto = "NOVABIENESTO";
		}
		return _tipoDevuelto;
	}

	// private static Attributes devolverAtributo(Symbol.Types a, Token t){
	// 	Attributes atributo;
	// 	if (a == Symbol.Types.STRING) {
			
	// 	} else {
	// 		atributo = new Attributes(a,Symbol.ParameterClass.NONE,null, true);
	// 	}
	// 	return atributo;
	// }

	private static String generarLabel() {
		return "L" + labelCounter++;
	}

	// funcion para escribir el bloque de codigo en el fichero codigo.p
	public static void escribirBloque(CodeBlock bloque) {
		try {
			FileWriter fichero = new FileWriter(nombreFichero);
			PrintWriter pw = new PrintWriter(fichero);
			pw.println(bloque.toString());
			fichero.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Funcion que dado un valor bool en la pila, escribe true o false en función
	// del valor que hubiese en la pila
	public static void escribirBool(CodeBlock block) {
		block.addComment("Escribir booleano");
		String etiquetaElse = generarLabel();
		String etiquetaFin = generarLabel();
		block.addComment("Si era false, entonces saltar a " + etiquetaElse);
		block.addInst(OpCode.JMF, etiquetaElse);
		block.addInst(OpCode.STC, 116);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 114);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 117);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 101);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.JMP, etiquetaFin);
		block.addLabel(etiquetaElse);
		block.addInst(OpCode.STC, 102);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 97);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 108);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 115);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 101);
		block.addInst(OpCode.WRT, 0);
		block.addLabel(etiquetaFin);
	}

	// Funcion que escribe en la pila el mensaje "ERROR" y salta al final del programa
	public static void escribirError(CodeBlock block) {
		block.addComment("Escribir ERROR");
		block.addLabel("ERROR");
		block.addInst(OpCode.STC, 69);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 82);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 82);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 79);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 82);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.STC, 10);
		block.addInst(OpCode.WRT, 0);
		block.addInst(OpCode.JMP, "FIN");
	}
}

PARSER_END(clike_4)

TOKEN : {
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
}

SKIP : {
	"\t" | "\n" | " " | "\r" | "."
}

TOKEN : {
	< tBOOL: "bool" >
|	< tCHAR: "char" >
|	< tINT: "int" >
|	< tVOID: "void" >
|	< tMAIN: "main" >
|	< tBARRACOMENTARIO: "//" >
| 	< tMAS: "+" >
| 	< tMENOS: "-" >
| 	< tMULTIPLICACION: "*" >
| 	< tDIVISION: "/" >
|	< tCOMA: "," >
|	< tPCOMA: ";" >
|	< tDOSPUNTOS: ":" >
|	< tNOT: "!" >
|	< tOR: "||" >
|	< tAND: "&&" >
|	< tREF: "&" >
|	< tTRUE: "true" >
|	< tFALSE: "false" >
|	< tDOBLEIGUAL: "==" >
|	< tIGUAL: "=" >
|	< tLPARENTESIS: "(" >
|	< tRPARENTESIS: ")" >
|	< tIF: "if" >
|	< tELSE: "else" >
|	< tWHILE: "while" >
|	< tREAD: "read" >
|	< tREADLN: "read_ln" >
|	< tPRINT: "print" >
|	< tPRINTLN: "print_ln" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tCOMILLASIMPLE: "'" >
|	< tLLLAVE: "{" >
|	< tRLLAVE: "}" >
|	< tLCORCHETE: "[" >
|	< tRCORCHETE: "]" >
|	< tRETURN: "return" >
|	< tBARRABAJA: "_" >
|	< tMAYOR: ">" >
|	< tMENOR: "<" >
|	< tMAYORIGUAL: ">=" >
|	< tMENORIGUAL: "<=" >
|	< tDIFERENTE: "!=" >
|	< tMODULO: "%" >
|	< tENTRECOMILLAS: "\"" ((~["\n","\r","\t","\""]) | ["\""]["\""])* "\"" >
|	< tENTRECOMILLASSIMPLES: "'" ((~["\n","\r","\t"])) "'" >
|	< tID: (<LETTER> | <tBARRABAJA>)(<LETTER> | <DIGIT> | <tBARRABAJA>)* >
|	< tDIGITO: (<DIGIT>)+ >
}

SPECIAL_TOKEN : {
	< tCOMENTARIO : (< tBARRACOMENTARIO > (~["\n","\r","\t"])* "\n" ) >
	  	{}
|	< tBASURA: ~[] >
		{
			clike_4.errLex("No sabes programar");
		}
}


//----------------------- MAQUINA P ---------------------
/*
• Operadores aritméticos:
	PLUS push (pop2() + pop1())
	SBT push (pop2() - pop1())
	TMS push (pop2() * pop1())
	MOD push (pop2() mod pop1())
	DIV push (pop2() div pop1())
	NGI push (-pop())

• Operadores lógicos:
	AND push (pop2() and pop1())
	OR push (pop2() or pop1())
	EQ push (pop2() = pop1())
	NEQ push (pop2() <> pop1())
	LT push (pop2() < pop1())
	LTE push (pop2() <= pop1())
	GT push (pop2() > pop1())
	GTE push (pop2() >= pop1())
	NGB push (not pop())

• Entrada/salida:
	RD n if n = 0 read char and
		store at frames[pop()]
		else as int
	WRT n if n = 0 write pop()
					as char
		else as int

• Miscelánea
	NOP
	SWP push (pop1(); pop2())
	DUP push (pop1(); pop1())
	POP pop()

• Comentarios
	; <linea>

• Referencia a datos:
	STC n store constant push(n)
	SRF f o set reference push (display[DP - f] + o)
	DRF dereference push (frames[pop()])
	ASG assign frames[pop2()] = pop1()
	ASGI assign inverse frames[pop1()] = pop2()

• Control de flujo:
	ENP n enter program at n
	LVP leave program
	JMP n PC = n
	JMT n pop()=1? PC = n else PC = PC+1
	JMF n pop()=0? PC = n else PC = PC+1
	OSF s l a open stack frame (crear BA)
	CSF close stack frame (destruir BA)
*/




//----------------------   PROGRAMA (MAIN)    ----------------------

// Funciones o declaraciones seguidas de un main
void Programa() : {
	CodeBlock block = new CodeBlock();
}
{
	{
		//tabla.insertBlock();
		block.addInst(OpCode.ENP, "MAIN");
		escribirError(block);
	}
	(LOOKAHEAD(3) FuncYDeclaracion(block))*
	Main(block)
	<EOF>
	{
		block.addLabel("FIN");
		block.addInst(OpCode.LVP);
		// Obtener el contador de errores, y si es mayor que 0 no generar el fichero
		if (errSem.getContadorErrores() > 0) {
			System.out.println("Se han encontrado " + errSem.getContadorErrores() + " errores semánticos.");
			System.out.println("No se ha generado el fichero " + nombreFichero);
		} else {
			// Generar el fichero
			escribirBloque(block);
			int warnings = errSem.getContadorWarnings();
			System.out.println("Compilación finalizada con (" + warnings + ") warnings. Se ha generado el fichero " + nombreFichero);
		}
		//tabla.removeBlock();
	}
}

void FuncYDeclaracion(CodeBlock block) : {}
{ 

	LOOKAHEAD(3) Def(block) |
	Funcs(block)
}

void Funcs(CodeBlock block) : {} 
{
	Func(block) |
	Proced(block)
}

// Programa main 
void Main(CodeBlock block) : {}
{
	{block.addLabel("MAIN");}
	
	<tVOID> <tMAIN> <tLPARENTESIS> <tRPARENTESIS> <tLLLAVE> 
	(Def(block))*
	(CodigoSinDSinRet(block))*
	<tRLLAVE>
	{
		// Comprobar si hay variables sin utilizar
		List<Symbol> simbolos = tabla.getSimbolos();
		// Recorrer todos los simbolos comprobando si el atributo 'utilizado' es false
		for (Symbol simbolo : simbolos) {
			if (!simbolo.utilizado) {
				errSem.warning("El simbolo " + simbolo.name + " no se utiliza en el main");
			}
		}
	}
	
}

// Tipos validos para devolver en funciones * no void *
Symbol.Types TipoVal() : {
    Symbol.Types tipo;
}
{
    <tINT> { tipo = Symbol.Types.INT; return tipo;}|
    <tCHAR> { tipo = Symbol.Types.CHAR; return tipo;} |
    <tBOOL> { tipo = Symbol.Types.BOOL; return tipo;}
}

void Func(CodeBlock bloqueGeneral) : {
	Symbol.Types tipo;
	ArrayList<Symbol> parametros = new ArrayList<>();
	Token t = new Token();
	SymbolFunction sFunc = null;
	String label;
	CodeBlock block = new CodeBlock();
}
{
	tipo = TipoVal() // Almacenar el tipo retornado por TipoVal() en la variable 'tipo'
	t = <tID> <tLPARENTESIS>
	(Param(parametros, block))?
	// Almacenar el valor de la funcion en la tabla
	{ 
		label = generarLabel();
		block.addComment("Funcion " + t.image + " (label: " + label + ")");
		block.addLabel(label);
		// Añadir la definición de la función a la tabla e insertar nuevo bloque
		sFunc = new SymbolFunction(t.image,parametros,tipo, label);
		try {
			tabla.insertSymbol(sFunc);
		} catch (AlreadyDefinedSymbolException e) {
			errSem.deteccion(e, t);
		}
		tabla.insertBlock(); 
		for (Symbol parametro : parametros) {
			try {
				parametro.inicializado = true;
				tabla.insertSymbol(parametro);
			} catch (AlreadyDefinedSymbolException e) {
				errSem.deteccion(e, t);
			}
		}
		// Asignar los parametros a sus valores reales
		block.addComment("Asignación de parametros");
		int tam = tabla.getFunctionSize();
		//block.addComment("El tamaño de parametros es " + tam);
		for (int i = tam; i >= 3; i--) {
			block.addInst(OpCode.SRF, 0, i);
			block.addInst(OpCode.ASGI);
		}

	} 
	<tRPARENTESIS> <tLLLAVE> 
	(Def(block))*
	(CodigoSinD(tipo,block))*
	<tRLLAVE>
	{ 
		// Comprobar si hay variables sin utilizar
		List<Symbol> simbolos = tabla.getSimbolos();
		// Recorrer todos los simbolos comprobando si el atributo 'utilizado' es false
		for (Symbol simbolo : simbolos) {
			if (!simbolo.utilizado && simbolo.nivel > 0) {
				errSem.warning("El simbolo " + simbolo.name + " no se utiliza en la funcion " + t.image);
			}
		}
		// Comprobar si hay al menos un return
		if (contadorReturns <= 0) {
			errSem.deteccion("La funcion " + t.image + " no tiene return", t);
		}
		contadorReturns = 0;
		tabla.removeBlock(); 
		block.addInst(OpCode.CSF);
		bloqueGeneral.addBlock(block);
		escribirBloque(block);
	}
}

void Proced(CodeBlock bloqueGeneral) : {
	ArrayList<Symbol> parametros = new ArrayList<>();
	Token t = new Token();
	SymbolProcedure sProc = null;
	String label;
	CodeBlock block = new CodeBlock();
}
{
	<tVOID> t = <tID> <tLPARENTESIS>
	(Param(parametros, block))?
	{ 
		label = generarLabel();
		block.addComment("Procedimiento " + t.image + " (label: " + label + ")");
		block.addLabel(label);
		// Añadir la definición de la función a la tabla e insertar nuevo bloque
		sProc = new SymbolProcedure(t.image,parametros, label);
		try {
			tabla.insertSymbol(sProc);
		} catch (AlreadyDefinedSymbolException e) {
			errSem.deteccion(e, t);
		}
		tabla.insertBlock(); 
		for (Symbol parametro : parametros) {
			try {
				parametro.inicializado = true;
				tabla.insertSymbol(parametro);
			} catch (AlreadyDefinedSymbolException e) {
				errSem.deteccion(e, t);
			}
		}
		// Asignar los parametros a sus valores reales
		block.addComment("Asignación de parametros");
		int tam = tabla.getFunctionSize();
		//block.addComment("El tamaño de parametros es " + tam);
		for (int i = tam; i >= 3; i--) {
			// Obtener el simbolo del parametro
			// Symbol parametro = parametros.get(i);
			// block.addComment("Val(" + parametro.name + ")");
			// if (parametro instanceof SymbolArray) {
			// 	SymbolArray array = (SymbolArray) parametro;
			// 	if (parametro.parClass == Symbol.ParameterClass.VAL) {
			// 		// Para cada uno de los componentes leer su valor
			// 		for (int j = array.maxInd; j > 0; j--) {
			// 			block.addInst(OpCode.SRF, 0, j + i + 3);
			// 			block.addInst(OpCode.ASGI);
			// 		}
			// 	}
			// }
			block.addInst(OpCode.SRF, 0, i);
			block.addInst(OpCode.ASGI);
		}
	} 
	<tRPARENTESIS> <tLLLAVE> 
	(Def(block))*
	(CodigoSinDSinRet(block))*
	<tRLLAVE>
	{ 	
		// Comprobar si hay variables sin utilizar
		List<Symbol> simbolos = tabla.getSimbolos();
		// Recorrer todos los simbolos comprobando si el atributo 'utilizado' es false
		for (Symbol simbolo : simbolos) {
			if (!simbolo.utilizado && simbolo.nivel > 0) {
				errSem.warning("El simbolo " + simbolo.name + " no se utiliza en el procedimiento " + t.image );
			}
		}
		tabla.removeBlock(); 
		block.addInst(OpCode.CSF);
		bloqueGeneral.addBlock(block);
	}
}

void ReturnValor(Symbol.Types tipo, CodeBlock block) : {
	Attributes a = null;
}
{
	<tRETURN> a = Expresion(block) <tPCOMA>
	{
		comprobarTipoReturn(a,tipo);
		block.addInst(OpCode.CSF);
		contadorReturns++;
	}
}

// Parametros puede ser ninguno, 1 o una lista
void Param(ArrayList<Symbol> parametros, CodeBlock block) : {
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
	Symbol.ParameterClass clase =  Symbol.ParameterClass.VAL;;
	Attributes atributo;
	boolean esVector = false;
	
	SymbolArray vec; 
	SymbolBool simboloBool;
	SymbolInt simboloEntero;
	SymbolChar simboloChar;
	Token id = new Token();
}
{
	tipo = TipoVal() 
	( <tREF>  {clase = Symbol.ParameterClass.REF;} )?
	id = <tID> 
	(
		{
			tokenActual = id;
		}

		atributo = vector(block) 
		{
			esVector = true;
			vec = new SymbolArray(id.image, atributo.valInt, tipo, clase);
			parametros.add(vec);	// Añadir parametro a la lista
		}
	)?
	{	
		if (!esVector) {
			// No es array
			switch (tipo) {
				case INT:
					simboloEntero = new SymbolInt(id.image,clase);
					parametros.add(simboloEntero);
					break;
				case CHAR:
					simboloChar = new SymbolChar(id.image, clase);
					parametros.add(simboloChar);
					break;
				case BOOL:
					simboloBool = new SymbolBool(id.image, clase);
					parametros.add(simboloBool);
					break; 
				default:
					break;
			}
		} 
	}
	(ListaParam(parametros, block))*
}

// Parametros que son vectores
Attributes vector(CodeBlock block) : {
	Attributes at;
}
{	
	(<tLCORCHETE> at = Expresion(block) <tRCORCHETE>)
	{
		comprobarInt(at);
		if (at.valInt < 0) {
			errSem.deteccion(new ArraySizeException(), tokenActual);
		}
		return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE,at.valInt);
	}
}

// Parametros que son vectores
Attributes vector_const(CodeBlock block) : {
	Attributes at;
	
}
{	
	(<tLCORCHETE> at = Expresion_simple_const(block) <tRCORCHETE>)
	{
		comprobarInt(at);
		if (at.valInt < 0) {
			errSem.deteccion(new ArraySizeException(), tokenActual);
		}
		return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE,at.valInt);
	}
}


// Lista de parametros 
void ListaParam(ArrayList<Symbol> parametros, CodeBlock block) : {
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
	Symbol.ParameterClass clase =  Symbol.ParameterClass.VAL;;
	Attributes atributo;
	boolean esVector = false;
	
	SymbolArray vec; 
	SymbolBool simboloBool;
	SymbolInt simboloEntero;
	SymbolChar simboloChar;
	Token id = new Token();
}

{
	<tCOMA> tipo=TipoVal() 
	(<tREF> {clase = Symbol.ParameterClass.REF;} )? 
	id = <tID> 
	(
		{
			tokenActual = id;
		}
		atributo = vector(block) 
		{
			esVector = true;
			vec = new SymbolArray(id.image, atributo.valInt, tipo, clase);
			parametros.add(vec);	// Añadir parametro a la lista
		}
	)?
	{	
		if (!esVector) {
			// No es array
			switch (tipo) {
				case INT:
					simboloEntero = new SymbolInt(id.image,clase);
					parametros.add(simboloEntero);
					break;
				case CHAR:
					simboloChar = new SymbolChar(id.image, clase);
					parametros.add(simboloChar);
					break;
				case BOOL:
					simboloBool = new SymbolBool(id.image, clase);
					parametros.add(simboloBool);
					break; 
				default:
					break;
			}
		} 
	}
}

// Instruccion concreta dentro de una funcion SIN DECLARACIONES
void CodigoSinD(Symbol.Types tipo, CodeBlock block) : {}
{
	LOOKAHEAD(2) Asig(block) | 
	While(tipo, block) |
	If(tipo, block) |
	Print(block) |
	Read(block) |
	LOOKAHEAD(2) LlamaProced(block) <tPCOMA> |
	ReturnValor(tipo, block)
}

// Instruccion concreta dentro de una funcion SIN DECLARACIONES
void CodigoSinDSinRet(CodeBlock block) : {}
{
	LOOKAHEAD(2) Asig(block) | 
	WhileSinRet(block) |
	IfSinRet(block) |
	Print(block) |
	Read(block) |
	LOOKAHEAD(2) LlamaProced(block) <tPCOMA>
}

//----------------------   LLAMADAS FUNCION    ----------------------

Attributes LlamaFunc(CodeBlock block) : {
	Token t = new Token();
	Symbol simbolo = null;
	ArrayList<Symbol> parametros = null;
	ArrayList<Attributes> parametrosLlamada = null;
	Symbol.Types tipo = null;
	String etiqueta = "";
}
{
	t = <tID> 
	{
		simbolo = tabla.getSymbol(t.image);
		if (simbolo instanceof SymbolFunction) {
			parametros = ((SymbolFunction)simbolo).parList;
			tipo = ((SymbolFunction)simbolo).returnType;
		}
		simbolo.utilizado = true;
	}
	<tLPARENTESIS> parametrosLlamada = PasoPar(block, parametros) <tRPARENTESIS> 
	{
		comprobarParametros(parametros,parametrosLlamada, t);
		int tamanyoOcupado = tabla.getFunctionSize();
		if (simbolo instanceof SymbolFunction) {
			etiqueta = ((SymbolFunction)simbolo).label;
		} else if (simbolo instanceof SymbolProcedure) {
			etiqueta = ((SymbolProcedure)simbolo).label;
		}
		block.addOSFInst(tamanyoOcupado + 1,tabla.level - simbolo.nivel, etiqueta);
		return new Attributes(tipo,Symbol.ParameterClass.NONE,null);
	}
}

void LlamaProced(CodeBlock block) : {
	Token t = new Token();
	Symbol simbolo = null;
	ArrayList<Symbol> parametros = null;
	ArrayList<Attributes> parametrosLlamada = null;
	String etiqueta = "";
}
{
	t = <tID> 
	{
		simbolo = tabla.getSymbol(t.image);
		if (simbolo instanceof SymbolProcedure) {
			parametros = ((SymbolProcedure)simbolo).parList;
		}
		simbolo.utilizado = true;
	}
	<tLPARENTESIS> parametrosLlamada = PasoPar(block, parametros) <tRPARENTESIS> 
	{
		comprobarParametros(parametros,parametrosLlamada, t);
		int tamanyoOcupado = tabla.getFunctionSize();
		if (simbolo instanceof SymbolFunction) {
			etiqueta = ((SymbolFunction)simbolo).label;
		} else if (simbolo instanceof SymbolProcedure) {
			etiqueta = ((SymbolProcedure)simbolo).label;
		}
		block.addOSFInst(tamanyoOcupado + 1,tabla.level - simbolo.nivel, etiqueta);
	}

}


ArrayList<Attributes> PasoPar(CodeBlock block, ArrayList<Symbol> parametros) : {
	Attributes a = null;
	ArrayList<Attributes> parametrosLlamada = new ArrayList<Attributes>();
	int cuenta = 0;
}
{
	(a = Expresion(block)
	{		
		parametrosLlamada.add(a);
		if (parametros.get(0).parClass == Symbol.ParameterClass.REF) {
			block.removeLastInst();
			comprobarNoConstante(a);
			block.addComment("Parametro por referencia");
		} 
		if (parametros.get(0).parClass == Symbol.ParameterClass.VAL && parametros.get(0) instanceof SymbolArray) {
			SymbolArray array = (SymbolArray) parametros.get(0);
			if (a.parClass == Symbol.ParameterClass.REF) {
				block.addComment("Vector por valor que era referencia");
				for (int i = 1; i <= array.maxInd; i++) {
					int nivel = tabla.level - array.nivel;
					if (nivel < 0) {
						nivel = 0;
					}
					block.addInst(OpCode.SRF, nivel, a.posicionPila);
					block.addInst(OpCode.DRF);
					block.addInst(OpCode.STC, i);
					block.addInst(OpCode.PLUS);
					block.addInst(OpCode.DRF);
				}
			} else {
				for (int i = 1; i <= array.maxInd; i++) {
					int nivel = tabla.level - array.nivel;
					if (nivel < 0) {
						nivel = 0;
					}
					block.addInst(OpCode.SRF, nivel, a.posicionPila + i);
					block.addInst(OpCode.DRF);
				}
			}
		}
	}
	(PosiblesPar(parametrosLlamada, block, parametros, cuenta)))?
	{return parametrosLlamada;}
}

// Lista de posibles parametros separados por comas
void PosiblesPar(ArrayList<Attributes> parametrosLlamada, CodeBlock block, ArrayList<Symbol> parametros, int cuenta) : {
	Attributes a = null;
}
{
	(<tCOMA> a = Expresion(block) 
	{
		cuenta++;
		parametrosLlamada.add(a);
		if (parametros.get(cuenta).parClass == Symbol.ParameterClass.REF) {
			block.removeLastInst();
			comprobarNoConstante(a);
			block.addComment("Parametro por referencia");
		} 
		if (parametros.get(cuenta).parClass == Symbol.ParameterClass.VAL && parametros.get(cuenta) instanceof SymbolArray) {
			SymbolArray array = (SymbolArray) parametros.get(cuenta);
			if (a.parClass == Symbol.ParameterClass.REF) {
				block.addComment("Vector por valor que era referencia");
				for (int i = 1; i <= array.maxInd; i++) {
					int nivel = tabla.level - array.nivel;
					if (nivel < 0) {
						nivel = 0;
					}
					block.addInst(OpCode.SRF, nivel, a.posicionPila);
					block.addInst(OpCode.DRF);
					block.addInst(OpCode.STC, i);
					block.addInst(OpCode.PLUS);
					block.addInst(OpCode.DRF);
				}
			} else {
				for (int i = 1; i <= array.maxInd; i++) {
					int nivel = tabla.level - array.nivel;
					if (nivel < 0) {
						nivel = 0;
					}
					block.addInst(OpCode.SRF, nivel, a.posicionPila + i);
					block.addInst(OpCode.DRF);
				}
			}
		}
	})*
}

//----------------------   DEFINICION    ----------------------

// Definicion "normal" o vectorial
void Def(CodeBlock block) : {
	Token t = new Token();
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
	boolean esVector = false;
	Attributes atributo = null;
}
{
	tipo = TipoVal() // Almacenar el tipo retornado por TipoVal() en el atributo
	(
		t = <tID>  
	(
		atributo = vector_const(block) 
		{
			esVector = true;
			SymbolArray s = new SymbolArray(t.image, atributo.valInt, tipo, Symbol.ParameterClass.NONE);
			try {
				tabla.insertSymbol(s);
			} catch (AlreadyDefinedSymbolException e) {
				errSem.deteccion(e, t);
			}
		}
	)?
		{
			if (!esVector) {
				if (tipo == Symbol.Types.INT) {
					SymbolInt s = new SymbolInt(t.image,Symbol.ParameterClass.NONE);

					try {
						tabla.insertSymbol(s);
					} catch (AlreadyDefinedSymbolException e) {
						errSem.deteccion(e, t);
					}
				} else if (tipo == Symbol.Types.BOOL) {
					SymbolBool s = new SymbolBool(t.image,Symbol.ParameterClass.NONE);

					try {
						tabla.insertSymbol(s);
					} catch (AlreadyDefinedSymbolException e) {
						errSem.deteccion(e, t);
					}
				} else if (tipo == Symbol.Types.CHAR) {
					// Tipo char
					SymbolChar s = new SymbolChar(t.image,Symbol.ParameterClass.NONE);

					try {
						tabla.insertSymbol(s);
					} catch (AlreadyDefinedSymbolException e) {
						errSem.deteccion(e, t);
					}
				}
			}
		}
		(Vars(tipo, block))* <tPCOMA>
	)
}

// Variables
void Vars(Symbol.Types tipo, CodeBlock block) : {
	Token t = new Token();
	boolean esVector = false;
	Attributes atributo = null;
}
{
	<tCOMA> t=<tID> 
	(
		atributo = vector_const(block) 
		{
			esVector = true;
			SymbolArray s = new SymbolArray(t.image, atributo.valInt, tipo, Symbol.ParameterClass.NONE);
			try {
				tabla.insertSymbol(s);
			} catch (AlreadyDefinedSymbolException e) {
				errSem.deteccion(e, t);
			}
		}
	)?

	{
		if (!esVector) {
			if (tipo == Symbol.Types.INT) {
				SymbolInt s = new SymbolInt(t.image,Symbol.ParameterClass.NONE);

				try {
					tabla.insertSymbol(s);
				} catch (AlreadyDefinedSymbolException e) {
					errSem.deteccion(e, t);
				}
			} else if (tipo == Symbol.Types.BOOL) {
				SymbolBool s = new SymbolBool(t.image,Symbol.ParameterClass.NONE);

				try {
					tabla.insertSymbol(s);
				} catch (AlreadyDefinedSymbolException e) {
					errSem.deteccion(e, t);
				}
			} else if (tipo == Symbol.Types.CHAR) {
				// Tipo char
				SymbolChar s = new SymbolChar(t.image,Symbol.ParameterClass.NONE);

				try {
					tabla.insertSymbol(s);
				} catch (AlreadyDefinedSymbolException e) {
					errSem.deteccion(e, t);
				}
			}
		}
	}
}

//----------------------   ASIGNACION    ----------------------

// Asignacion normal y vectorial
void Asig(CodeBlock block) : {
	Attributes a;
	Token t;
	Symbol simbolo;
	Symbol.Types tipo = null;
	SymbolArray array;

}
{
	LOOKAHEAD(2) t=<tID> 
	{
		tokenActual = t;
		simbolo = tabla.getSymbol(t.image); 
		simbolo.inicializado = true;
		block.addComment("@(" + simbolo.name + ")"); 
		block.addInst(OpCode.SRF,tabla.level - simbolo.nivel,simbolo.posicionPila);
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
	} 
	<tIGUAL> a=Expresion(block) <tPCOMA> 
	{
		comprobarTiposAsignacion(simbolo,a);
		block.addInst(OpCode.ASG);
	}
	|
	LOOKAHEAD(2) t = <tID> 	
	{ 
		tokenActual = t;
		simbolo = tabla.getSymbol(t.image); 
		block.addComment("@(" + simbolo.name + ")"); 
		block.addInst(OpCode.SRF,tabla.level - simbolo.nivel,simbolo.posicionPila);
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
	} 
	vector(block) 
	{
		simbolo = tabla.getSymbol(t.image);
		array = (SymbolArray)simbolo;
		int tamanyo = array.maxInd + 1;
		block.addInst(OpCode.DUP);
		block.addInst(OpCode.STC, tamanyo); 
		block.addInst(OpCode.GT);
		block.addInst(OpCode.JMT, "ERROR");
		block.addInst(OpCode.PLUS);
	} 
	<tIGUAL> a=Expresion(block) <tPCOMA>
	{
		simbolo = tabla.getSymbol(t.image);
		if (simbolo instanceof SymbolArray) {
			tipo = ((SymbolArray)simbolo).baseType;
			block.addInst(OpCode.ASG);
		}
		
		comprobarTiposAsignacionVec(tipo,a);
	}
}


//----------------------   IF    ----------------------
void If(Symbol.Types tipo, CodeBlock block) : {
	Attributes a = null;
	Boolean hayElse = false;
	String labelFin = "";
}
{
	{ block.addComment("Estructura IF");}
	<tIF> <tLPARENTESIS> a = Expresion(block)
	{
		String labelElse = generarLabel();
		block.addInst(OpCode.JMF, labelElse);
		block.addComment("Caso True");
	} 
	 <tRPARENTESIS> <tLLLAVE> (CodigoSinD(tipo, block))* <tRLLAVE> 
	(
	{
		labelFin = generarLabel();
		block.addComment("Salto al final del if");
		block.addInst(OpCode.JMP, labelFin);
		block.addLabel(labelElse);
		block.addComment("Caso False");
		hayElse = true;
	}
	IfElse(tipo, block))?
	{ 
		comprobarBool(a);
		if (!hayElse) {
			block.addLabel(labelElse);
		} else {
			block.addLabel(labelFin);
		}

	}
}

void IfSinRet(CodeBlock block) : {
	Attributes a = null;
	String labelFin = "";
	Boolean hayElse = false;
}
{
	{ block.addComment("Estructura IF");}
	<tIF> <tLPARENTESIS> a=Expresion(block) 
	{
		String labelElse = generarLabel();
		block.addInst(OpCode.JMF, labelElse);
		block.addComment("Caso True");

	} 
	<tRPARENTESIS> <tLLLAVE> (CodigoSinDSinRet(block))* <tRLLAVE> 
	{
		labelFin = generarLabel();
		block.addComment("Salto al final del if");
		block.addInst(OpCode.JMP, labelFin);
		block.addLabel(labelElse);
		block.addComment("Caso False");
		hayElse = true;
	}
	IfElseSinRet(block)
	{ 
		comprobarBool(a);
		if (!hayElse) {
			block.addLabel(labelElse);
		} else {
			block.addLabel(labelFin);
		}
	}
}


//--------------------   IF ELSE    --------------------
void IfElse(Symbol.Types tipo, CodeBlock block) : {
}
{
	<tELSE> <tLLLAVE> (CodigoSinD(tipo, block))* <tRLLAVE> 
}

void IfElseSinRet(CodeBlock block) : {
	Attributes a = null;
}
{
	<tELSE> <tLLLAVE> (CodigoSinDSinRet(block))* <tRLLAVE> |
	{}
}

//----------------------   WHILE    ----------------------
void While(Symbol.Types tipo, CodeBlock block) : {
	Attributes a = null;
	String labelFin = generarLabel();
	String labelInicio = generarLabel();
}
{
	<tWHILE> <tLPARENTESIS> 
	{
		block.addComment("Estructura WHILE");
		block.addLabel(labelInicio);
	}
		a = Expresion(block)
	{
		block.addInst(OpCode.JMF, labelFin);
		block.addComment("Bucle True");
	}  
	<tRPARENTESIS> <tLLLAVE> (CodigoSinD(tipo, block))* <tRLLAVE>
	{ 
		comprobarBool(a);
		block.addComment("Salto al inicio del while");
		block.addInst(OpCode.JMP, labelInicio);
		block.addComment("Final del while");
		block.addLabel(labelFin);
	}
}

void WhileSinRet(CodeBlock block) : {
	Attributes a = null;
	String labelFin = generarLabel();
	String labelInicio = generarLabel();
}
{
	<tWHILE> <tLPARENTESIS> 
	{
		block.addComment("Estructura WHILE");
		block.addLabel(labelInicio);
	}
	a = Expresion(block) 
	{
		block.addInst(OpCode.JMF, labelFin);
		block.addComment("Bucle True");
	}  
	<tRPARENTESIS> <tLLLAVE> (CodigoSinDSinRet(block))* <tRLLAVE>
	{ 
		comprobarBool(a);
		block.addComment("Salto al inicio del while");
		block.addInst(OpCode.JMP, labelInicio);
		block.addComment("Final del while");
		block.addLabel(labelFin);
	}
}

//----------------------   PRINT    ----------------------
void Print(CodeBlock block) : {}
{
	PrintN(block) | PrintLn(block)
}

// Print normal
void PrintN(CodeBlock block) : {
	Attributes a = null;
}
{
	<tPRINT> <tLPARENTESIS> a = Expresion(block) 
	{
		comprobarTipoValidoString(a);
		if (a.type == Symbol.Types.INT) {
			block.addInst(OpCode.WRT, 1);
		} else if (a.type == Symbol.Types.BOOL) {
			escribirBool(block);
		} else if (a.type == Symbol.Types.CHAR) {
			block.addInst(OpCode.WRT, 0);
		} else if (a.type == Symbol.Types.STRING) {
			// Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
			// en la pila
			for (int i = 1; i < a.valString.length() - 1; i++) {
				block.addInst(OpCode.STC, (int)a.valString.charAt(i));
				block.addInst(OpCode.WRT, 0);
			}
		}
	} 
	(ListaPrint(block))* <tRPARENTESIS> <tPCOMA>
	
}

// Lista en el print con comas
void ListaPrint(CodeBlock block) : {
	Attributes a = null;
}
{
	<tCOMA> a = Expresion(block)
	
	{
		comprobarTipoValidoString(a);
		if (a.type == Symbol.Types.INT) {
			block.addInst(OpCode.WRT, 1);
		} else if (a.type == Symbol.Types.BOOL) {
			escribirBool(block);
		} else if (a.type == Symbol.Types.CHAR) {
			block.addInst(OpCode.WRT, 0);
		} else if (a.type == Symbol.Types.STRING) {
			// Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
			// en la pila
			for (int i = 1; i < a.valString.length() - 1; i++) {
				block.addInst(OpCode.STC, (int)a.valString.charAt(i));
				block.addInst(OpCode.WRT, 0);
			}
		}
	}
}

// PrintLn
void PrintLn(CodeBlock block) : {}
{
	<tPRINTLN> <tLPARENTESIS> ListaPrintLn(block) <tRPARENTESIS> <tPCOMA>	
}

// Lista en el println con comas
void ListaPrintLn(CodeBlock block) : {
	Attributes a = null;
}
{
	(a = Expresion(block) 
	{
		comprobarTipoValidoString(a);
		if (a.type == Symbol.Types.INT) {
			block.addInst(OpCode.WRT, 1);
		} else if (a.type == Symbol.Types.BOOL) {
			escribirBool(block);
		} else if (a.type == Symbol.Types.CHAR) {
			block.addInst(OpCode.WRT, 0);
		} else if (a.type == Symbol.Types.STRING) {
			// Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
			// en la pila
			for (int i = 1; i < a.valString.length() - 1; i++) {
				block.addInst(OpCode.STC, (int)a.valString.charAt(i));
				block.addInst(OpCode.WRT, 0);
			}
		}
	}
	(ListaPrint(block))* {comprobarTipoValidoString(a);})?
	{
		block.addInst(OpCode.STC, 10);
		block.addInst(OpCode.WRT, 0);
	}
}

//----------------------   READ    ----------------------
void Read(CodeBlock block) : {}
{
	ReadN(block) | ReadLn(block)
}

// Read normal
void ReadN(CodeBlock block) : {
	Token t = new Token();
	Symbol simbolo = null;
	boolean esVector = false;
	Symbol.Types a = null;
}
{
	<tREAD> <tLPARENTESIS> t=<tID> {tokenActual = t;} (vector(block) {esVector = true;})? 
	{
		simbolo = tabla.getSymbol(t.image);
		simbolo.utilizado = true;
		block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
		// Si es por referencia, hacer un DRF
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
		if (esVector) {
			if (simbolo instanceof SymbolArray) {
				// Ver de que tipo es el vector
				a = ((SymbolArray)simbolo).baseType; 
				comprobarTipoValido(a);
				block.addInst(OpCode.PLUS);
			}
		} else {
			comprobarTipoValido(simbolo);
			a = simbolo.type;
		}
		if (a == Symbol.Types.INT) {
			block.addInst(OpCode.RD, 1);
		} else if (a == Symbol.Types.BOOL) {
			block.addInst(OpCode.RD, 0);
		} else if (a == Symbol.Types.CHAR) {
			block.addInst(OpCode.RD, 0);
		}
		
	}
	ListaRead(block) <tRPARENTESIS> <tPCOMA>

}

// Lista en el read con comas
void ListaRead(CodeBlock block) : {
	Token t = new Token();
	Symbol simbolo = null;
	boolean esVector = false;
	Symbol.Types a = null;
}
{
	(<tCOMA> t=<tID> 
	{
		tokenActual = t;
	}
	(vector(block) {esVector = true;})? ListaRead(block) {simbolo = tabla.getSymbol(t.image); comprobarTipoValido(simbolo);}
	{
		simbolo = tabla.getSymbol(t.image); 
		simbolo.utilizado = true;
		block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
		// Si es por referencia, hacer un DRF
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
		if (esVector) {
			if (simbolo instanceof SymbolArray) {
				// Ver de que tipo es el vector
				a = ((SymbolArray)simbolo).baseType; 
				comprobarTipoValido(a);
			}
		} else {
			comprobarTipoValido(simbolo);
			a = simbolo.type;
		}
		if (a == Symbol.Types.INT) {
			block.addInst(OpCode.RD, 1);
		} else if (a == Symbol.Types.BOOL) {
			block.addInst(OpCode.RD, 0);
		} else if (a == Symbol.Types.CHAR) {
			block.addInst(OpCode.RD, 0);
		}
	}
	)?
}

// ReadLn
void ReadLn(CodeBlock block) : {}
{
	<tREADLN> <tLPARENTESIS> ListaReadLn(block) <tRPARENTESIS> <tPCOMA>	
}

// Lista en el ReadLn con comas
void ListaReadLn(CodeBlock block) : {
	Token t = new Token();
	Symbol simbolo = null;
	boolean esVector = false;
	Symbol.Types a = null;
}
{
	(t = <tID> 
	{
		tokenActual = t;
	}
	(vector(block) {esVector = true;})? 
	{
		simbolo = tabla.getSymbol(t.image); 
		simbolo.utilizado = true;
		block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
		// Si es por referencia, hacer un DRF
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
		if (esVector) {
			if (simbolo instanceof SymbolArray) {
				// Ver de que tipo es el vector
				a = ((SymbolArray)simbolo).baseType; 
				comprobarTipoValido(a);
				block.addInst(OpCode.PLUS);
			}
		} else {
			comprobarTipoValido(simbolo);
			a = simbolo.type;
		}
		if (a == Symbol.Types.INT) {
			block.addInst(OpCode.RD, 1);
		} else if (a == Symbol.Types.BOOL) {
			block.addInst(OpCode.RD, 0);
		} else if (a == Symbol.Types.CHAR) {
			block.addInst(OpCode.RD, 0);
		}
		
	}
	ListaRead(block))?
}

//----------------------   EXPRESION    ----------------------
Attributes Expresion(CodeBlock block): {
	Attributes a;
	Attributes b;
}
{
	a = Relacion(block) ( b = Mas_relation(a,block) {return comprobarTipos(a,b);} )?
	{return a;} // Devolver el tipo si solo es 1
}


Attributes Mas_relation(Attributes b, CodeBlock block): {
	Attributes a;
	int op;
}
{
	( op = And_or(block) a = Relacion(block) 
	{
		comprobarBool(a);
		if (op == 1) {
			block.addInst(OpCode.OR);
		} else if (op == 2) {
			block.addInst(OpCode.AND);
		}
		a.constante = a.constante && b.constante;
	} 
	)+
	{return a;}
}

int And_or(CodeBlock block): {}
{
	< tOR > {return 1;}
|	< tAND > {return 2;}
}

Attributes Relacion(CodeBlock block): {
	Attributes a;
	Attributes b;
	int op;
}
{
	a = Expresion_simple(block)
	( 
		op = Operador_relacional(block)
		b = Expresion_simple(block)
		{
			// Aplicar la operacion
			if (op == 1) {
				block.addInst(OpCode.EQ);
			} else if (op == 2) {
				if (a.type == Symbol.Types.INT) {
					comprobarInt(a);
					comprobarInt(b);
				} else if (a.type == Symbol.Types.CHAR) {
					comprobarChar(a);
					comprobarChar(b);
				}
				block.addInst(OpCode.LT);
			} else if (op == 3) {
				if (a.type == Symbol.Types.INT) {
					comprobarInt(a);
					comprobarInt(b);
				} else if (a.type == Symbol.Types.CHAR) {
					comprobarChar(a);
					comprobarChar(b);
				}
				block.addInst(OpCode.GT);
			} else if (op == 4) {
				if (a.type == Symbol.Types.INT) {
					comprobarInt(a);
					comprobarInt(b);
				} else if (a.type == Symbol.Types.CHAR) {
					comprobarChar(a);
					comprobarChar(b);
				}
				block.addInst(OpCode.LTE);
			} else if (op == 5) {
				if (a.type == Symbol.Types.INT) {
					comprobarInt(a);
					comprobarInt(b);
				} else if (a.type == Symbol.Types.CHAR) {
					comprobarChar(a);
					comprobarChar(b);
				}
				block.addInst(OpCode.GTE);
			} else {
				block.addInst(OpCode.NEQ);
			}
			a.constante = a.constante && b.constante;
			comprobarTipos(a,b); 
			return new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,null, a.constante);
		}
	)?
	{return a;}
}

int Operador_relacional(CodeBlock block): {}
{
	< tDOBLEIGUAL > {return 1;}
|	< tMENOR > {return 2;}
|	< tMAYOR > {return 3;}
|	< tMENORIGUAL > {return 4;}
|	< tMAYORIGUAL > {return 5;}
|	< tDIFERENTE > {return 6;}
}

Attributes Expresion_simple(CodeBlock block): {
	Attributes a;
	Attributes b;
	boolean esEntero = false;
	int o = 0;
	int op;
}
{
	( 
		o = Op_MAS_MENOS(block) {esEntero = true;}
	)? 
	a = Termino(block)
	{
		if (o == 2) {
			// Negar el termino
			block.addInst(OpCode.NGI);
		}
	}
	( 
		LOOKAHEAD(2) op = Op_MAS_MENOS(block) 
		b = Termino(block)
		{
			comprobarInt(b);
		    esEntero = true;
			if (a.constante && b.constante) {
				// Quitar las ultimas 4 operaciones (2 para cada factor y su comentario)
				block.removeLastInst();
				block.removeLastInst();
				block.removeLastInst();
				block.removeLastInst();
				// Si son constantes, hacer la operacion
				if (op == 1) {
					a.valInt = a.valInt + b.valInt;
				} else if (op == 2) {
					a.valInt = a.valInt - b.valInt;
				} 
				block.addComment("Operacion constante resuelta en tiempo de compilacion (valor = " + a.valInt + ")");
				block.addInst(OpCode.STC, a.valInt);
			} else {
				a.constante = false;
				// Aplicar la operacion
				if (op == 1) {
					block.addInst(OpCode.PLUS);
				} else {
					block.addInst(OpCode.SBT);
				}
			}
		}
	)*
	{
		if (esEntero) {
			// Si se utiliza el operador '+' o '-', verificar que es del tipo int
			comprobarInt(a);
		}
		return a;
	}
}

int Op_MAS_MENOS(CodeBlock block) : {}
{
	< tMAS > {return 1;}
|	< tMENOS > {return 2;}
}

Attributes Termino(CodeBlock block): {
	Attributes a;
	Attributes b;
	boolean esEntero = false;
	int op;
}
{
	a = Factor(block)
	( 
		op = Op_MULT(block) 
		b = Factor(block)
		{
			comprobarInt(b);
			esEntero = true;
			if (a.constante && b.constante) {
				// Quitar las ultimas 4 operaciones (2 para cada factor y su comentario)
				block.removeLastInst();
				block.removeLastInst();
				block.removeLastInst();
				block.removeLastInst();
				// Si son constantes, hacer la operacion
				if (op == 1) {
					a.valInt = a.valInt * b.valInt;
				} else if (op == 2) {
					a.valInt = a.valInt/ b.valInt;
				} else {
					a.valInt = a.valInt % b.valInt;
				}
				block.addComment("Operacion constante resuelta en tiempo de compilacion (valor = " + a.valInt + ")");
				block.addInst(OpCode.STC, a.valInt);
			} else {
				a.constante = false;
				// Aplicar la operacion
				if (op == 1) {
					block.addInst(OpCode.TMS);
				} else if (op == 2) {
					block.addInst(OpCode.DIV);
				} else {
					block.addInst(OpCode.MOD);
				}
			}
		}
	)*
	{
		if (esEntero) {
			// Si se utiliza el operador '*' o '/' o '%', verificar que es del tipo int
			comprobarInt(a);
		}
		return a;
	}
}	

int Op_MULT(CodeBlock block): {}
{
		< tMULTIPLICACION > {return 1;}
	|	< tDIVISION > {return 2;}
	|	< tMODULO> {return 3;}
}

Attributes Factor(CodeBlock block): {
	Attributes a;
}
{
	a = Primario(block) {return a;} |	
	< tNOT > a = Primario(block) 
	{
		comprobarBool(a); 
		if (a.constante) {
			// Como es constante podemos negar el valor directamente
			// Quitamos el valor que hubiese en la pila y metemos el negado
			block.removeLastInst();
			block.removeLastInst(); // Para quitar el comentario
			block.addComment("Varibale constante negada");
			if (a.valBool) {
				a.valBool = false;
				block.addInst(OpCode.STC,0);
			} else {
				a.valBool = true;
				block.addInst(OpCode.STC,1);
			}
		} else {
			a.constante = false;
			block.addInst(OpCode.NGB);
		}
	}
	{return a;}
}

Attributes Primario(CodeBlock block): {
	Attributes atributo = null;
	Attributes atributoNuevo = null;
	Symbol.Types a = null;
	Token t = new Token();
	Symbol simbolo = null;
}
{
		< tLPARENTESIS > atributo = Expresion(block) < tRPARENTESIS > {return atributo;}
	|	< tINT2CHAR > < tLPARENTESIS > atributo = Expresion(block) < tRPARENTESIS > 
	{
		// Verificar que la expresion es un entero
		comprobarInt(atributo);
		atributoNuevo = new Attributes(Symbol.Types.CHAR,Symbol.ParameterClass.NONE,null);
		atributoNuevo.token = atributo.token;
		return atributoNuevo;
	}
	|	< tCHAR2INT > < tLPARENTESIS > atributo = Expresion(block) < tRPARENTESIS > 
	{
		// Verificar que la expresion es un entero
		comprobarChar(atributo);
		atributoNuevo = new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,null);
		atributoNuevo.token = atributo.token;
		return atributoNuevo;
	}
	//|	LOOKAHEAD(2) < tID > < tLPARENTESIS > (Expresion())+ < tRPARENTESIS >
	|	LOOKAHEAD(2) t=< tID >
	{
		simbolo = tabla.getSymbol(t.image); 
		if (!simbolo.inicializado && simbolo.nivel > 0) {
			// Generar un warning para informar que se esta utilizando una variable no inicializada
			errSem.warning("La variable no ha sido inicializada",t);
		}
		simbolo.utilizado = true;
		block.addComment("ValArray(" + simbolo.name + ")");
		block.addInst(OpCode.SRF, tabla.level - simbolo.nivel,simbolo.posicionPila);
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
	}
	< tLCORCHETE > atributo = Expresion(block) < tRCORCHETE >
	{
		comprobarInt(atributo);
		block.addInst(OpCode.PLUS);
		block.addInst(OpCode.DRF);
		simbolo = tabla.getSymbol(t.image);
		if (simbolo instanceof SymbolArray) {
			a = ((SymbolArray)simbolo).baseType; 
		}
		atributo = new Attributes(a,simbolo.parClass,atributo.valInt);
		atributo.token = t;
		return atributo;
	}
	|	LOOKAHEAD(2) atributo = LlamaFunc(block) {return atributo;}
	|	t = < tID > 
	{ 
		// Caso de una variable
		simbolo = tabla.getSymbol(t.image); 
		if (!simbolo.inicializado && simbolo.nivel > 0) {
			// Generar un warning para informar que se esta utilizando una variable no inicializada
			errSem.warning("La variable no ha sido inicializada",t);
		}
		simbolo.utilizado = true;
		block.addComment("Val(" + simbolo.name + ")");
		block.addInst(OpCode.SRF, tabla.level - simbolo.nivel,simbolo.posicionPila);
		block.addInst(OpCode.DRF);
		if (simbolo.parClass == Symbol.ParameterClass.REF) {
			block.addInst(OpCode.DRF);
		}
		atributo = new Attributes(simbolo.type,simbolo.parClass,t.image); 
		atributo.posicionPila = simbolo.posicionPila;
		atributo.token = t;
		return atributo;
	}
	| 	t = < tDIGITO > 
	{
		block.addComment("Constante entera igual a " + t.image);
		int valor = Integer.parseInt(t.image);
		block.addInst(OpCode.STC,valor); 
		atributo = new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,valor, true);
		atributo.token = t;
		return atributo;
	}
	|	t = < tTRUE > 
	{
		block.addComment("Constante true");
		block.addInst(OpCode.STC,1); 
		atributo = new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,true, true);
		atributo.token = t;
		return atributo;
	}
	|	t = < tFALSE > 
	{
		block.addComment("Constante false");
		block.addInst(OpCode.STC,0); 
		atributo = new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,false, true);
		atributo.token = t;
		return atributo;
	}
	|	t = < tENTRECOMILLAS > 
	{
		// Calcular el ascii del caracter
		return new Attributes(Symbol.Types.STRING,Symbol.ParameterClass.NONE,t.image, true);
	}
	|	t = < tENTRECOMILLASSIMPLES > 
	{
		block.addComment("Constante char");
		block.addInst(OpCode.STC,(int)t.image.charAt(1)); 
		atributo =  new Attributes(Symbol.Types.CHAR,Symbol.ParameterClass.NONE,t.image, true);
		atributo.token = t;
		return atributo;	
	}

}


//----------------------   EXPRESION DE CONSTANTES   ----------------------

Attributes Expresion_simple_const(CodeBlock block): {
	Attributes a;
	Attributes b;
	boolean esEntero = false;
	int operacion;
	int operacion2 = 0;
	int resultado;
}
{
	( 
		operacion2 = Op_MAS_MENOS(block) {esEntero = true;}
	)? 
	a = Termino_const(block)
	{
		if (esEntero) {
			if (operacion2 == 2) {
				resultado = -a.valInt;
			} else {
				resultado = a.valInt;
			}
		} else {
			resultado = a.valInt;
		}
	}
	( 
		LOOKAHEAD(2) operacion = Op_MAS_MENOS(block) 
		b = Termino_const(block)
		{
			comprobarInt(b);
		    esEntero = true;
			if (operacion == 2) {
				resultado = resultado - b.valInt;
			} else {
				resultado = resultado + b.valInt;
			}
		}
	)*
	{
		if (esEntero) {
			// Si se utiliza el operador '+' o '-', verificar que es del tipo int
			comprobarInt(a);
			a.valInt = resultado;
			block.addInst(OpCode.STC, resultado);
		}
		return a;
	}
}

Attributes Termino_const(CodeBlock block): {
	Attributes a;
	Attributes b;
	boolean esEntero = false;
	int resultado;
	int operacion;
}
{
	a = Primario_const(block) {resultado = a.valInt;}
	( 
		operacion = Op_MULT(block) 
		b = Primario_const(block)
		{
			comprobarInt(b);
			esEntero = true;
			switch(operacion){
				case 1:
					// multiplicacion
					resultado = resultado * b.valInt;
					break;
				case 2:
					// Division
					resultado = resultado / b.valInt;
					break;
				case 3:
					// Modulo
					resultado = resultado % b.valInt;
					break;
			}
		}
	)*
	{
		if (esEntero) {
			// Si se utiliza el operador '*' o '/' o '%', verificar que es del tipo int
			comprobarInt(a);
		}
		a.valInt = resultado;
		return a;
	}
}	

Attributes Primario_const(CodeBlock block): {
	Attributes atributo = null;
	Token t = new Token();
}
{
		< tLPARENTESIS > atributo = Expresion_simple_const(block) < tRPARENTESIS > {return atributo;}
	| 	t = < tDIGITO > 
	{
	
		atributo = new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,Integer.parseInt(t.image));
		atributo.token = t;
		return atributo;
	}
}