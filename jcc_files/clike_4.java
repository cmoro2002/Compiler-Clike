/* clike_4.java */
/* Generated By:JavaCC: Do not edit this line. clike_4.java */
// TODO:
//	* Crear diferentes bloques e ir juntandolos a medida que subimos el arbol
// 	* Añadir a los attributes un campo que sea si es constante, para poder realizar operaciones con constantes
// 	* Arreglar paso de constantes por referencia
//	* Codigo: Variables globales
// 		- Hay un STC en medio de la nada en criba_eratostenes
//  * Añadir niveles

package traductor;

import lib.symbolTable.Symbol;
import lib.symbolTable.SymbolTable;
import lib.symbolTable.SymbolArray;
import lib.symbolTable.SymbolBool;
import lib.symbolTable.SymbolChar;
import lib.symbolTable.SymbolFunction;
import lib.symbolTable.SymbolInt;
import lib.symbolTable.SymbolProcedure;
import lib.attributes.Attributes;
import java.util.ArrayList;
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;
import java.io.PrintWriter;
import java.io.FileWriter;

public class clike_4 implements clike_4Constants {
        private static final int SALTO_LINEA = 10;
        private static String[] pals = {"int2char","char2int","print","print_ln","read","read_ln",
                        "main","int","bool","void","char","if","while","else","return","true","false"};
        private static SymbolTable tabla = new SymbolTable(pals);
        private static ErrorSemantico errSem = new ErrorSemantico();

        public static int functionCounter = 1;

        public static int labelCounter = 1;
        public static String nombreFichero = "";

    public static void main(String[] args) {
        clike_4 parser = null;
                // El nombre del fichero será el primer parametro
                nombreFichero = args[0];
                nombreFichero = nombreFichero.substring(0, nombreFichero.length() - 2);
                nombreFichero = nombreFichero + "pcode";

        try {
                if(args.length == 0) {
                                parser = new clike_4(System.in);
                        }
                        else {
                    parser = new clike_4(new java.io.FileInputStream(args[0]));
                        }
                        //Programa es el símbolo inicial de la gramática
                        parser.Programa();
                        //...
                        System.out.println("***** An\u00e1lisis terminado con \u00e9xito *****");
                }
                catch (java.io.FileNotFoundException e) {
                        System.err.println ("Fichero " + args[0] + " no encontrado.");
                        System.exit(1);
                }
                catch (TokenMgrError e) {
                System.err.println("Token mgr error: " + e.getMessage());
                        System.exit(1);
        }
        catch (ParseException e) {
                        // Cambiar el error
                        System.err.println("Parse error: " + e.getMessage());
                        System.exit(1);
                }
    }

        public static void errLex(String error) {
                System.out.println(error);
                System.exit(1);
        }

        // Comprueba que ambos atributos sean del mismo tipo
        public static Attributes comprobarTipos(Attributes a, Attributes b) {
                if (a.type != b.type) {
                        throw new NotMachingTypes(a, b);
                } else {
                        return a;
                }
        }

        // Comprueba que ambos atributos sean del mismo tipo
        public static Attributes comprobarTiposAsignacion(Symbol simbolo, Attributes a) {
                if (a.type != simbolo.type) {
                        String _tipoVar = obtenerTipo(simbolo.type);
                String _tipoDevuelto = obtenerTipo(a.type);
                        String mensaje = "Los tipos son incompatibles: " + _tipoVar + ", " + _tipoDevuelto;
                        throw new IncompatibleTypes(mensaje);
                } else {
                        return a;
                }
        }

        // Comprueba que ambos atributos sean del mismo tipo cuando uno es un vector
        public static Attributes comprobarTiposAsignacionVec(Symbol.Types tipo, Attributes a) {
                if (a.type != tipo) {
                        String _tipoVar = obtenerTipo(tipo);
                String _tipoDevuelto = obtenerTipo(a.type);
                        String mensaje = "Los tipos son incompatibles: " + _tipoVar + ", " + _tipoDevuelto;
                        throw new IncompatibleTypes(mensaje);
                } else {
                        return a;
                }
        }

        // Comprueba que el atributo a es boolean
        public static void comprobarBool(Attributes a) {
                if (a.type != Symbol.Types.BOOL) {
                        throw new NotBoolean(a);
                }
        }

        // Comprueba que el atributo a es entero
        public static void comprobarInt (Attributes a) {
                if (a.type != Symbol.Types.INT) {
                        throw new NotInt(a);
                }
        }

        // Comprueba que el atributo a es entero
        public static void comprobarChar (Attributes a) {
                if (a.type != Symbol.Types.CHAR) {
                        throw new NotChar(a);
                }
        }

        // Comprueba que el atributo a es entero
        public static void comprobarTipoValido (Symbol simbolo) {
                if (simbolo.type != Symbol.Types.CHAR && simbolo.type != Symbol.Types.INT && simbolo.type != Symbol.Types.BOOL) {
                        throw new NotTipoValido(simbolo);
                }
        }

        // Comprueba que el atributo a es entero
        public static void comprobarTipoValido (Symbol.Types simbolo) {
                if (simbolo != Symbol.Types.CHAR && simbolo != Symbol.Types.INT && simbolo != Symbol.Types.BOOL) {
                        throw new NotTipoValido(simbolo);
                }
        }

        // Comprueba que el atributo a es entero
        public static void comprobarTipoValidoString (Attributes a) {
                if (a.type != Symbol.Types.CHAR && a.type != Symbol.Types.INT && a.type != Symbol.Types.BOOL && a.type != Symbol.Types.STRING) {
                        throw new NotTipoValido(a);
                }
        }

        // Comprueba si coincide el valor devuelto y el tipo que devuelve la funcion
        public static void comprobarTipoReturn (Attributes a, Symbol.Types tipo) {
                String _tipoVar = obtenerTipo(a.type);
        String _tipoDevuelto = obtenerTipo(tipo);

                String mensaje = "";

                if (!_tipoVar.equals(_tipoDevuelto)) {
                        mensaje = "La funci\u00f3n esperaba devolver el tipo " + _tipoVar + "y se ha devuelto el tipo " + _tipoDevuelto;
                        throw new IncompatibleTypes(mensaje);
                }
        }

                // Comprueba si coincide el valor devuelto y el tipo que devuelve la funcion
        public static void comprobarTipoParametro (Attributes a, Symbol.Types tipo) {
                String _tipoVar = obtenerTipo(a.type);
        String _tipoDevuelto = obtenerTipo(tipo);

                String mensaje = "";
                if (!_tipoVar.equals(_tipoDevuelto)) {
                        mensaje = "bbsita bebelin La funci\u00f3n esperaba un parametro de tipo " + _tipoVar + "y se llamado con el tipo " + _tipoDevuelto;
                        throw new IncompatibleTypes(mensaje);
                }
        }

        public static void comprobarParametros(ArrayList<Symbol> lista1,ArrayList<Attributes> lista2) {
                String mensaje = "";
                if (lista1.size() != lista2.size()) {
                        mensaje = "El n\u00famero de par\u00e1metros no coincide";
                        throw new IncompatibleSizes(mensaje);
                } else {
                        for (int i = 0; i < lista1.size(); i++) {
                                if (lista1.get(i).type != lista2.get(i).type) {
                                        throw new IncompatibleTypes("Tipos no compatibles :)");
                                }
                        }
                }
        }

        private static String obtenerTipo(Symbol.Types tipo) {
        String _tipoDevuelto = "";

                // Pasamos a string el tipo
        if (tipo == Symbol.Types.INT) {
            _tipoDevuelto = "int";
        } else if (tipo == Symbol.Types.BOOL) {
            _tipoDevuelto = "bool";
        } else if (tipo == Symbol.Types.CHAR) {
                        _tipoDevuelto = "char";
                } else if (tipo == Symbol.Types.ARRAY) {
                        _tipoDevuelto = "array";
                } else {
                        _tipoDevuelto = "NOVABIENESTO";
                }
                return _tipoDevuelto;
        }

        private static Attributes devolverAtributo(Symbol.Types a, Token t){
                Attributes atributo;
                if (a == Symbol.Types.STRING) {
                        atributo = new Attributes(a,Symbol.ParameterClass.NONE,t.image);
                } else {
                        atributo = new Attributes(a,Symbol.ParameterClass.NONE,null);
                }
                return atributo;
        }

        private static String generarLabel() {
                return "L" + labelCounter++;
        }

        // funcion para escribir el bloque de codigo en el fichero codigo.p
        public static void escribirBloque(CodeBlock bloque) {
                try {
                        FileWriter fichero = new FileWriter(nombreFichero);
                        PrintWriter pw = new PrintWriter(fichero);
                        pw.println(bloque.toString());
                        fichero.close();
                } catch (Exception e) {
                        e.printStackTrace();
                }
        }

        // Funcion que dado un valor bool en la pila, escribe true o false en función
        // del valor que hubiese en la pila
        public static void escribirBool(CodeBlock block) {
                block.addComment("Escribir booleano");
                String etiquetaElse = generarLabel();
                String etiquetaFin = generarLabel();
                block.addComment("Si era false, entonces saltar a " + etiquetaElse);
                block.addInst(OpCode.JMF, etiquetaElse);
                block.addInst(OpCode.STC, 116);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 114);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 117);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 101);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.JMP, etiquetaFin);
                block.addLabel(etiquetaElse);
                block.addInst(OpCode.STC, 102);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 97);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 108);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 115);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 101);
                block.addInst(OpCode.WRT, 0);
                block.addLabel(etiquetaFin);
        }

        // Funcion que escribe en la pila el mensaje "ERROR" y salta al final del programa
        public static void escribirError(CodeBlock block) {
                block.addComment("Escribir ERROR");
                block.addLabel("ERROR");
                block.addInst(OpCode.STC, 69);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 82);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 82);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 79);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 82);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.STC, 10);
                block.addInst(OpCode.WRT, 0);
                block.addInst(OpCode.JMP, "FIN");
        }

//----------------------- MAQUINA P ---------------------
/*
• Operadores aritméticos:
	PLUS push (pop2() + pop1())
	SBT push (pop2() - pop1())
	TMS push (pop2() * pop1())
	MOD push (pop2() mod pop1())
	DIV push (pop2() div pop1())
	NGI push (-pop())

• Operadores lógicos:
	AND push (pop2() and pop1())
	OR push (pop2() or pop1())
	EQ push (pop2() = pop1())
	NEQ push (pop2() <> pop1())
	LT push (pop2() < pop1())
	LTE push (pop2() <= pop1())
	GT push (pop2() > pop1())
	GTE push (pop2() >= pop1())
	NGB push (not pop())

• Entrada/salida:
	RD n if n = 0 read char and
		store at frames[pop()]
		else as int
	WRT n if n = 0 write pop()
					as char
		else as int

• Miscelánea
	NOP
	SWP push (pop1(); pop2())
	DUP push (pop1(); pop1())
	POP pop()

• Comentarios
	; <linea>

• Referencia a datos:
	STC n store constant push(n)
	SRF f o set reference push (display[DP - f] + o)
	DRF dereference push (frames[pop()])
	ASG assign frames[pop2()] = pop1()
	ASGI assign inverse frames[pop1()] = pop2()

• Control de flujo:
	ENP n enter program at n
	LVP leave program
	JMP n PC = n
	JMT n pop()=1? PC = n else PC = PC+1
	JMF n pop()=0? PC = n else PC = PC+1
	OSF s l a open stack frame (crear BA)
	CSF close stack frame (destruir BA)
*/




//----------------------   PROGRAMA (MAIN)    ----------------------

// Funciones o declaraciones seguidas de un main
  static final public void Programa() throws ParseException {CodeBlock block = new CodeBlock();
//tabla.insertBlock();
                block.addInst(OpCode.ENP, "MAIN");
                escribirError(block);
    label_1:
    while (true) {
      if (jj_2_1(3)) {
        ;
      } else {
        break label_1;
      }
      FuncYDeclaracion(block);
    }
    Main(block);
    jj_consume_token(0);
block.addLabel("FIN");
                block.addInst(OpCode.LVP);
                escribirBloque(block);
                //tabla.removeBlock();

}

  static final public void FuncYDeclaracion(CodeBlock block) throws ParseException {
    if (jj_2_2(3)) {
      Def(block);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:
      case tVOID:{
        Funcs(block);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
}

  static final public void Funcs(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tBOOL:
    case tCHAR:
    case tINT:{
      Func(block);
      break;
      }
    case tVOID:{
      Proced(block);
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

// Programa main 
  static final public void Main(CodeBlock block) throws ParseException {
block.addLabel("MAIN");
    jj_consume_token(tVOID);
    jj_consume_token(tMAIN);
    jj_consume_token(tLPARENTESIS);
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      Def(block);
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      CodigoSinDSinRet(block);
    }
    jj_consume_token(tRLLAVE);
}

// Tipos validos para devolver en funciones * no void *
  static final public Symbol.Types TipoVal() throws ParseException {Symbol.Types tipo;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tINT:{
      jj_consume_token(tINT);
tipo = Symbol.Types.INT; {if ("" != null) return tipo;}
      break;
      }
    case tCHAR:{
      jj_consume_token(tCHAR);
tipo = Symbol.Types.CHAR; {if ("" != null) return tipo;}
      break;
      }
    case tBOOL:{
      jj_consume_token(tBOOL);
tipo = Symbol.Types.BOOL; {if ("" != null) return tipo;}
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public void Func(CodeBlock bloqueGeneral) throws ParseException {Symbol.Types tipo;
        ArrayList<Symbol> parametros = new ArrayList<>();
        Token t = new Token();
        SymbolFunction sFunc = null;
        String label;
        CodeBlock block = new CodeBlock();
    tipo = TipoVal();
    // Almacenar el tipo retornado por TipoVal() en la variable 'tipo'
            t = jj_consume_token(tID);
    jj_consume_token(tLPARENTESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tBOOL:
    case tCHAR:
    case tINT:{
      Param(parametros, block);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
label = generarLabel();
                block.addComment("Funcion " + t.image + " (label: " + label + ")");
                block.addLabel(label);
                // Añadir la definición de la función a la tabla e insertar nuevo bloque
                sFunc = new SymbolFunction(t.image,parametros,tipo, label);
                // sFunc.nivel = functionCounter++;
                System.out.println(tabla.toString());
                try {
                        tabla.insertSymbol(sFunc);
                } catch (AlreadyDefinedSymbolException e) {
                        errSem.deteccion(e, t);
                }
                tabla.insertBlock();
                for (Symbol parametro : parametros) {
                        try {
                                tabla.insertSymbol(parametro);
                        } catch (AlreadyDefinedSymbolException e) {
                                errSem.deteccion(e, t);
                        }
                }
                // Asignar los parametros a sus valores reales
                block.addComment("Asignaci\u00f3n de parametros");
                for (int i = parametros.size() - 1; i >= 0; i--) {
                        // Obtener el simbolo del parametro
                        Symbol parametro = parametros.get(i);
                        block.addComment("Val(" + parametro.name + ")");
                        if (parametro instanceof SymbolArray) {
                                SymbolArray array = (SymbolArray) parametro;
                                if (parametro.parClass == Symbol.ParameterClass.VAL) {
                                        // Para cada uno de los componentes leer su valor
                                        for (int j = array.maxInd; j > 0; j--) {
                                                block.addInst(OpCode.SRF, 0, j + i + 3);
                                                block.addInst(OpCode.ASGI);
                                        }
                                }
                        }

                        block.addInst(OpCode.SRF, 0, i + 3);
                        block.addInst(OpCode.ASGI);
                }
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      Def(block);
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tRETURN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      CodigoSinD(tipo,block);
    }
    jj_consume_token(tRLLAVE);
tabla.removeBlock();
                block.addInst(OpCode.CSF);
                bloqueGeneral.addBlock(block);
                escribirBloque(block);
}

  static final public void Proced(CodeBlock bloqueGeneral) throws ParseException {ArrayList<Symbol> parametros = new ArrayList<>();
        Token t = new Token();
        SymbolProcedure sProc = null;
        String label;
        CodeBlock block = new CodeBlock();
    jj_consume_token(tVOID);
    t = jj_consume_token(tID);
    jj_consume_token(tLPARENTESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tBOOL:
    case tCHAR:
    case tINT:{
      Param(parametros, block);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      ;
    }
label = generarLabel();
                block.addComment("Procedimiento " + t.image + " (label: " + label + ")");
                block.addLabel(label);
                // Añadir la definición de la función a la tabla e insertar nuevo bloque
                sProc = new SymbolProcedure(t.image,parametros, label);
                sProc.nivel = functionCounter++;
                System.out.println(tabla.toString());
                try {
                        tabla.insertSymbol(sProc);
                } catch (AlreadyDefinedSymbolException e) {
                        errSem.deteccion(e, t);
                }
                tabla.insertBlock();
                for (Symbol parametro : parametros) {
                        try {
                                tabla.insertSymbol(parametro);
                        } catch (AlreadyDefinedSymbolException e) {
                                errSem.deteccion(e, t);
                        }
                }
                // Asignar los parametros a sus valores reales
                block.addComment("Asignaci\u00f3n de parametros");
                for (int i = parametros.size() - 1; i >= 0; i--) {
                        // Obtener el simbolo del parametro
                        Symbol parametro = parametros.get(i);
                        block.addComment("Val(" + parametro.name + ")");
                        if (parametro instanceof SymbolArray) {
                                SymbolArray array = (SymbolArray) parametro;
                                if (parametro.parClass == Symbol.ParameterClass.VAL) {
                                        // Para cada uno de los componentes leer su valor
                                        for (int j = array.maxInd; j > 0; j--) {
                                                block.addInst(OpCode.SRF, 0, j + i + 3);
                                                block.addInst(OpCode.ASGI);
                                        }
                                }
                        }
                        block.addInst(OpCode.SRF, 0, i + 3);
                        block.addInst(OpCode.ASGI);
                }
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_6;
      }
      Def(block);
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        break label_7;
      }
      CodigoSinDSinRet(block);
    }
    jj_consume_token(tRLLAVE);
tabla.removeBlock();
                block.addInst(OpCode.CSF);
                bloqueGeneral.addBlock(block);
}

  static final public void ReturnValor(Symbol.Types tipo, CodeBlock block) throws ParseException {Attributes a = null;
    jj_consume_token(tRETURN);
    a = Expresion(block);
    jj_consume_token(tPCOMA);
comprobarTipoReturn(a,tipo);
                block.addInst(OpCode.CSF);
}

// Parametros puede ser ninguno, 1 o una lista
  static final public void Param(ArrayList<Symbol> parametros, CodeBlock block) throws ParseException {Symbol.Types tipo = Symbol.Types.UNDEFINED;
        Symbol.ParameterClass clase =  Symbol.ParameterClass.VAL;;
        Attributes atributo;
        boolean esVector = false;

        SymbolArray vec;
        SymbolBool simboloBool;
        SymbolInt simboloEntero;
        SymbolChar simboloChar;
        Token id = new Token();
    tipo = TipoVal();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tREF:{
      jj_consume_token(tREF);
clase = Symbol.ParameterClass.REF;
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLCORCHETE:{
      atributo = vector(block);
esVector = true;
                        vec = new SymbolArray(id.image, atributo.valInt, tipo, clase);
                        parametros.add(vec);    // Añadir parametro a la lista

      break;
      }
    default:
      jj_la1[12] = jj_gen;
      ;
    }
if (!esVector) {
                        // No es array
                        switch (tipo) {
                                case INT:
                                        simboloEntero = new SymbolInt(id.image,clase);
                                        parametros.add(simboloEntero);
                                        break;
                                case CHAR:
                                        simboloChar = new SymbolChar(id.image, clase);
                                        parametros.add(simboloChar);
                                        break;
                                case BOOL:
                                        simboloBool = new SymbolBool(id.image, clase);
                                        parametros.add(simboloBool);
                                        break;
                                default:
                                        break;
                        }
                }
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMA:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_8;
      }
      ListaParam(parametros, block);
    }
}

// Parametros que son vectores
  static final public Attributes vector(CodeBlock block) throws ParseException {Attributes at;
    jj_consume_token(tLCORCHETE);
    at = Expresion(block);
    jj_consume_token(tRCORCHETE);
comprobarInt(at);
                if (at.valInt < 0) {
                        {if (true) throw new ArraySizeException();}
                }
                {if ("" != null) return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE,at.valInt);}
    throw new Error("Missing return statement in function");
}

// Parametros que son vectores
  static final public Attributes vector_const(CodeBlock block) throws ParseException {Attributes at;
    jj_consume_token(tLCORCHETE);
    at = Expresion_simple_const(block);
    jj_consume_token(tRCORCHETE);
comprobarInt(at);
                if (at.valInt < 0) {
                        {if (true) throw new ArraySizeException();}
                }
                {if ("" != null) return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE,at.valInt);}
    throw new Error("Missing return statement in function");
}

// Lista de parametros 
  static final public void ListaParam(ArrayList<Symbol> parametros, CodeBlock block) throws ParseException {Symbol.Types tipo = Symbol.Types.UNDEFINED;
        Symbol.ParameterClass clase =  Symbol.ParameterClass.VAL;;
        Attributes atributo;
        boolean esVector = false;

        SymbolArray vec;
        SymbolBool simboloBool;
        SymbolInt simboloEntero;
        SymbolChar simboloChar;
        Token id = new Token();
    jj_consume_token(tCOMA);
    tipo = TipoVal();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tREF:{
      jj_consume_token(tREF);
clase = Symbol.ParameterClass.REF;
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLCORCHETE:{
      atributo = vector(block);
esVector = true;
                        vec = new SymbolArray(id.image, atributo.valInt, tipo, clase);
                        parametros.add(vec);    // Añadir parametro a la lista

      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
if (!esVector) {
                        // No es array
                        switch (tipo) {
                                case INT:
                                        simboloEntero = new SymbolInt(id.image,clase);
                                        parametros.add(simboloEntero);
                                        break;
                                case CHAR:
                                        simboloChar = new SymbolChar(id.image, clase);
                                        parametros.add(simboloChar);
                                        break;
                                case BOOL:
                                        simboloBool = new SymbolBool(id.image, clase);
                                        parametros.add(simboloBool);
                                        break;
                                default:
                                        break;
                        }
                }
}

// Instruccion concreta dentro de una funcion SIN DECLARACIONES
  static final public void CodigoSinD(Symbol.Types tipo, CodeBlock block) throws ParseException {
    if (jj_2_3(2)) {
      Asig(block);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:{
        While(tipo, block);
        break;
        }
      case tIF:{
        If(tipo, block);
        break;
        }
      case tPRINT:
      case tPRINTLN:{
        Print(block);
        break;
        }
      case tREAD:
      case tREADLN:{
        Read(block);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        if (jj_2_4(2)) {
          LlamaFuncYProced(block);
          jj_consume_token(tPCOMA);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case tRETURN:{
            ReturnValor(tipo, block);
            break;
            }
          default:
            jj_la1[17] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
}

// Instruccion concreta dentro de una funcion SIN DECLARACIONES
  static final public void CodigoSinDSinRet(CodeBlock block) throws ParseException {
    if (jj_2_5(2)) {
      Asig(block);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:{
        WhileSinRet(block);
        break;
        }
      case tIF:{
        IfSinRet(block);
        break;
        }
      case tPRINT:
      case tPRINTLN:{
        Print(block);
        break;
        }
      case tREAD:
      case tREADLN:{
        Read(block);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        if (jj_2_6(2)) {
          LlamaFuncYProced(block);
          jj_consume_token(tPCOMA);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
}

//----------------------   LLAMADAS FUNCION    ----------------------
  static final public 
Attributes LlamaFunc(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol simbolo = null;
        ArrayList<Symbol> parametros = null;
        ArrayList<Attributes> parametrosLlamada = null;
        Symbol.Types tipo = null;
        String etiqueta = "";
    t = jj_consume_token(tID);
simbolo = tabla.getSymbol(t.image);
                if (simbolo instanceof SymbolFunction) {
                        parametros = ((SymbolFunction)simbolo).parList;
                        tipo = ((SymbolFunction)simbolo).returnType;
                } else if (simbolo instanceof SymbolProcedure) {
                        {if (true) throw new ProcedureReturn(t.image);}
                }
    jj_consume_token(tLPARENTESIS);
    parametrosLlamada = PasoPar(block, parametros);
    jj_consume_token(tRPARENTESIS);
comprobarParametros(parametros,parametrosLlamada);
                int tamanyoOcupado = tabla.getFunctionSize();
                if (simbolo instanceof SymbolFunction) {
                        etiqueta = ((SymbolFunction)simbolo).label;
                } else if (simbolo instanceof SymbolProcedure) {
                        etiqueta = ((SymbolProcedure)simbolo).label;
                }
                block.addOSFInst(tamanyoOcupado + 1,tabla.level - simbolo.nivel, etiqueta);
                {if ("" != null) return new Attributes(tipo,Symbol.ParameterClass.NONE,null);}
    throw new Error("Missing return statement in function");
}

  static final public void LlamaFuncYProced(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol simbolo = null;
        ArrayList<Symbol> parametros = null;
        ArrayList<Attributes> parametrosLlamada = null;
        String etiqueta = "";
    t = jj_consume_token(tID);
simbolo = tabla.getSymbol(t.image);
                if (simbolo instanceof SymbolFunction) {
                        parametros = ((SymbolFunction)simbolo).parList;
                } else if (simbolo instanceof SymbolProcedure) {
                        parametros = ((SymbolProcedure)simbolo).parList;
                }
    jj_consume_token(tLPARENTESIS);
    parametrosLlamada = PasoPar(block, parametros);
    jj_consume_token(tRPARENTESIS);
comprobarParametros(parametros,parametrosLlamada);
                int tamanyoOcupado = tabla.getFunctionSize();
                if (simbolo instanceof SymbolFunction) {
                        etiqueta = ((SymbolFunction)simbolo).label;
                } else if (simbolo instanceof SymbolProcedure) {
                        etiqueta = ((SymbolProcedure)simbolo).label;
                }
                block.addOSFInst(tamanyoOcupado + 1,tabla.level - simbolo.nivel, etiqueta);
}

  static final public ArrayList<Attributes> PasoPar(CodeBlock block, ArrayList<Symbol> parametros) throws ParseException {Attributes a = null;
        ArrayList<Attributes> parametrosLlamada = new ArrayList<Attributes>();
        int cuenta = 0;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMAS:
    case tMENOS:
    case tNOT:
    case tTRUE:
    case tFALSE:
    case tLPARENTESIS:
    case tINT2CHAR:
    case tCHAR2INT:
    case tENTRECOMILLAS:
    case tENTRECOMILLASSIMPLES:
    case tID:
    case tDIGITO:{
      a = Expresion(block);
parametrosLlamada.add(a);
                if (parametros.get(0).parClass == Symbol.ParameterClass.REF) {
                        block.removeLastInst();
                        block.addComment("Parametro por referencia");
                }
                if (parametros.get(0).parClass == Symbol.ParameterClass.VAL && parametros.get(0) instanceof SymbolArray) {
                        SymbolArray array = (SymbolArray) parametros.get(0);
                        for (int i = 1; i <= array.maxInd; i++) {
                                block.addInst(OpCode.SRF, tabla.level - array.nivel + 1, array.posicionPila + i);
                                block.addInst(OpCode.DRF);
                        }
                }
      PosiblesPar(parametrosLlamada, block, parametros, cuenta);
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      ;
    }
{if ("" != null) return parametrosLlamada;}
    throw new Error("Missing return statement in function");
}

// Lista de posibles parametros separados por comas
  static final public void PosiblesPar(ArrayList<Attributes> parametrosLlamada, CodeBlock block, ArrayList<Symbol> parametros, int cuenta) throws ParseException {Attributes a = null;
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMA:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      jj_consume_token(tCOMA);
      a = Expresion(block);
parametrosLlamada.add(a);
                if (parametros.get(++cuenta).parClass == Symbol.ParameterClass.REF) {
                        block.removeLastInst();
                        block.addComment("Parametro por referencia");
                }
                if (parametros.get(0).parClass == Symbol.ParameterClass.VAL && parametros.get(cuenta) instanceof SymbolArray) {
                        SymbolArray array = (SymbolArray) parametros.get(cuenta);
                        for (int i = 1; i <= array.maxInd; i++) {
                                block.addInst(OpCode.SRF, tabla.level - array.nivel + 1, array.posicionPila + i);
                                block.addInst(OpCode.DRF);
                        }
                }
    }
}

//----------------------   DEFINICION    ----------------------

// Definicion "normal" o vectorial
  static final public void Def(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol.Types tipo = Symbol.Types.UNDEFINED;
        boolean esVector = false;
        Attributes atributo = null;
    tipo = TipoVal();
    t = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLCORCHETE:{
      atributo = vector_const(block);
esVector = true;
                        SymbolArray s = new SymbolArray(t.image, atributo.valInt, tipo, Symbol.ParameterClass.NONE);
                        try {
                                tabla.insertSymbol(s);
                        } catch (AlreadyDefinedSymbolException e) {
                                errSem.deteccion(e, t);
                        }
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      ;
    }
if (!esVector) {
                                if (tipo == Symbol.Types.INT) {
                                        SymbolInt s = new SymbolInt(t.image,Symbol.ParameterClass.NONE);

                                        try {
                                                tabla.insertSymbol(s);
                                        } catch (AlreadyDefinedSymbolException e) {
                                                errSem.deteccion(e, t);
                                        }
                                } else if (tipo == Symbol.Types.BOOL) {
                                        SymbolBool s = new SymbolBool(t.image,Symbol.ParameterClass.NONE);

                                        try {
                                                tabla.insertSymbol(s);
                                        } catch (AlreadyDefinedSymbolException e) {
                                                errSem.deteccion(e, t);
                                        }
                                } else if (tipo == Symbol.Types.CHAR) {
                                        // Tipo char
                                        SymbolChar s = new SymbolChar(t.image,Symbol.ParameterClass.NONE);

                                        try {
                                                tabla.insertSymbol(s);
                                        } catch (AlreadyDefinedSymbolException e) {
                                                errSem.deteccion(e, t);
                                        }
                                }
                        }
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMA:{
        ;
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        break label_10;
      }
      Vars(tipo, block);
    }
    jj_consume_token(tPCOMA);
System.out.println(tabla.toString());
}

// Variables
  static final public void Vars(Symbol.Types tipo, CodeBlock block) throws ParseException {Token t = new Token();
        boolean esVector = false;
        Attributes atributo = null;
    jj_consume_token(tCOMA);
    t = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLCORCHETE:{
      atributo = vector_const(block);
esVector = true;
                        SymbolArray s = new SymbolArray(t.image, atributo.valInt, tipo, Symbol.ParameterClass.NONE);
                        try {
                                tabla.insertSymbol(s);
                        } catch (AlreadyDefinedSymbolException e) {
                                errSem.deteccion(e, t);
                        }
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      ;
    }
if (!esVector) {
                        if (tipo == Symbol.Types.INT) {
                                SymbolInt s = new SymbolInt(t.image,Symbol.ParameterClass.NONE);

                                try {
                                        tabla.insertSymbol(s);
                                } catch (AlreadyDefinedSymbolException e) {
                                        errSem.deteccion(e, t);
                                }
                        } else if (tipo == Symbol.Types.BOOL) {
                                SymbolBool s = new SymbolBool(t.image,Symbol.ParameterClass.NONE);

                                try {
                                        tabla.insertSymbol(s);
                                } catch (AlreadyDefinedSymbolException e) {
                                        errSem.deteccion(e, t);
                                }
                        } else if (tipo == Symbol.Types.CHAR) {
                                // Tipo char
                                SymbolChar s = new SymbolChar(t.image,Symbol.ParameterClass.NONE);

                                try {
                                        tabla.insertSymbol(s);
                                } catch (AlreadyDefinedSymbolException e) {
                                        errSem.deteccion(e, t);
                                }
                        }
                }
}

//----------------------   ASIGNACION    ----------------------

// Asignacion normal y vectorial
  static final public void Asig(CodeBlock block) throws ParseException {Attributes a;
        Token t;
        Symbol simbolo;
        Symbol.Types tipo = null;
        SymbolArray array;
    if (jj_2_7(2)) {
      t = jj_consume_token(tID);
simbolo = tabla.getSymbol(t.image);
                block.addComment("@(" + simbolo.name + ")");
                block.addInst(OpCode.SRF,tabla.level - simbolo.nivel,simbolo.posicionPila);
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
      jj_consume_token(tIGUAL);
      a = Expresion(block);
      jj_consume_token(tPCOMA);
comprobarTiposAsignacion(simbolo,a);
                block.addInst(OpCode.ASG);
    } else if (jj_2_8(2)) {
      t = jj_consume_token(tID);
simbolo = tabla.getSymbol(t.image);
                block.addComment("@(" + simbolo.name + ")");
                block.addInst(OpCode.SRF,tabla.level - simbolo.nivel,simbolo.posicionPila);
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
      vector(block);
simbolo = tabla.getSymbol(t.image);
                array = (SymbolArray)simbolo;
                int tamanyo = array.maxInd + 1;
                block.addInst(OpCode.DUP);
                block.addInst(OpCode.STC, tamanyo);
                block.addInst(OpCode.GT);
                block.addInst(OpCode.JMT, "ERROR");
                block.addInst(OpCode.PLUS);
      jj_consume_token(tIGUAL);
      a = Expresion(block);
      jj_consume_token(tPCOMA);
simbolo = tabla.getSymbol(t.image);
                if (simbolo instanceof SymbolArray) {
                        tipo = ((SymbolArray)simbolo).baseType;
                        block.addInst(OpCode.ASG);
                }

                comprobarTiposAsignacionVec(tipo,a);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
}

//----------------------   IF    ----------------------
  static final public void If(Symbol.Types tipo, CodeBlock block) throws ParseException {Attributes a = null;
        Boolean hayElse = false;
        String labelFin = "";
block.addComment("Estructura IF");
    jj_consume_token(tIF);
    jj_consume_token(tLPARENTESIS);
    a = Expresion(block);
String labelElse = generarLabel();
                block.addInst(OpCode.JMF, labelElse);
                block.addComment("Caso True");
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tRETURN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_11;
      }
      CodigoSinD(tipo, block);
    }
    jj_consume_token(tRLLAVE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tELSE:{
labelFin = generarLabel();
                block.addComment("Salto al final del if");
                block.addInst(OpCode.JMP, labelFin);
                block.addLabel(labelElse);
                block.addComment("Caso False");
                hayElse = true;
      IfElse(tipo, block);
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      ;
    }
comprobarBool(a);
                if (!hayElse) {
                        block.addLabel(labelElse);
                } else {
                        block.addLabel(labelFin);
                }
}

  static final public void IfSinRet(CodeBlock block) throws ParseException {Attributes a = null;
        String labelFin = "";
        Boolean hayElse = false;
block.addComment("Estructura IF");
    jj_consume_token(tIF);
    jj_consume_token(tLPARENTESIS);
    a = Expresion(block);
String labelElse = generarLabel();
                block.addInst(OpCode.JMF, labelElse);
                block.addComment("Caso True");
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        break label_12;
      }
      CodigoSinDSinRet(block);
    }
    jj_consume_token(tRLLAVE);
labelFin = generarLabel();
                block.addComment("Salto al final del if");
                block.addInst(OpCode.JMP, labelFin);
                block.addLabel(labelElse);
                block.addComment("Caso False");
                hayElse = true;
    IfElseSinRet(block);
comprobarBool(a);
                if (!hayElse) {
                        block.addLabel(labelElse);
                } else {
                        block.addLabel(labelFin);
                }
}

//--------------------   IF ELSE    --------------------
  static final public void IfElse(Symbol.Types tipo, CodeBlock block) throws ParseException {
    jj_consume_token(tELSE);
    jj_consume_token(tLLLAVE);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tRETURN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        break label_13;
      }
      CodigoSinD(tipo, block);
    }
    jj_consume_token(tRLLAVE);
}

  static final public void IfElseSinRet(CodeBlock block) throws ParseException {Attributes a = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tELSE:{
      jj_consume_token(tELSE);
      jj_consume_token(tLLLAVE);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tIF:
        case tWHILE:
        case tREAD:
        case tREADLN:
        case tPRINT:
        case tPRINTLN:
        case tID:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_14;
        }
        CodigoSinDSinRet(block);
      }
      jj_consume_token(tRLLAVE);
      break;
      }
    default:
      jj_la1[29] = jj_gen;

    }
}

//----------------------   WHILE    ----------------------
  static final public void While(Symbol.Types tipo, CodeBlock block) throws ParseException {Attributes a = null;
        String labelFin = generarLabel();
        String labelInicio = generarLabel();
    jj_consume_token(tWHILE);
    jj_consume_token(tLPARENTESIS);
block.addComment("Estructura WHILE");
                block.addLabel(labelInicio);
    a = Expresion(block);
block.addInst(OpCode.JMF, labelFin);
                block.addComment("Bucle True");
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tRETURN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        break label_15;
      }
      CodigoSinD(tipo, block);
    }
    jj_consume_token(tRLLAVE);
comprobarBool(a);
                block.addComment("Salto al inicio del while");
                block.addInst(OpCode.JMP, labelInicio);
                block.addComment("Final del while");
                block.addLabel(labelFin);
}

  static final public void WhileSinRet(CodeBlock block) throws ParseException {Attributes a = null;
        String labelFin = generarLabel();
        String labelInicio = generarLabel();
    jj_consume_token(tWHILE);
    jj_consume_token(tLPARENTESIS);
block.addComment("Estructura WHILE");
                block.addLabel(labelInicio);
    a = Expresion(block);
block.addInst(OpCode.JMF, labelFin);
                block.addComment("Bucle True");
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tLLLAVE);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tIF:
      case tWHILE:
      case tREAD:
      case tREADLN:
      case tPRINT:
      case tPRINTLN:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_16;
      }
      CodigoSinDSinRet(block);
    }
    jj_consume_token(tRLLAVE);
comprobarBool(a);
                block.addComment("Salto al inicio del while");
                block.addInst(OpCode.JMP, labelInicio);
                block.addComment("Final del while");
                block.addLabel(labelFin);
}

//----------------------   PRINT    ----------------------
  static final public void Print(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPRINT:{
      PrintN(block);
      break;
      }
    case tPRINTLN:{
      PrintLn(block);
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

// Print normal
  static final public void PrintN(CodeBlock block) throws ParseException {Attributes a = null;
    jj_consume_token(tPRINT);
    jj_consume_token(tLPARENTESIS);
    a = Expresion(block);
comprobarTipoValidoString(a);
                if (a.type == Symbol.Types.INT) {
                        block.addInst(OpCode.WRT, 1);
                } else if (a.type == Symbol.Types.BOOL) {
                        escribirBool(block);
                } else if (a.type == Symbol.Types.CHAR) {
                        block.addInst(OpCode.WRT, 0);
                } else if (a.type == Symbol.Types.STRING) {
                        // Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
                        // en la pila
                        for (int i = 1; i < a.valString.length() - 1; i++) {
                                block.addInst(OpCode.STC, (int)a.valString.charAt(i));
                                block.addInst(OpCode.WRT, 0);
                        }
                }
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMA:{
        ;
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        break label_17;
      }
      ListaPrint(block);
    }
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tPCOMA);
}

// Lista en el print con comas
  static final public void ListaPrint(CodeBlock block) throws ParseException {Attributes a = null;
    jj_consume_token(tCOMA);
    a = Expresion(block);
comprobarTipoValidoString(a);
                if (a.type == Symbol.Types.INT) {
                        block.addInst(OpCode.WRT, 1);
                } else if (a.type == Symbol.Types.BOOL) {
                        escribirBool(block);
                } else if (a.type == Symbol.Types.CHAR) {
                        block.addInst(OpCode.WRT, 0);
                } else if (a.type == Symbol.Types.STRING) {
                        // Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
                        // en la pila
                        for (int i = 1; i < a.valString.length() - 1; i++) {
                                block.addInst(OpCode.STC, (int)a.valString.charAt(i));
                                block.addInst(OpCode.WRT, 0);
                        }
                }
}

// PrintLn
  static final public void PrintLn(CodeBlock block) throws ParseException {
    jj_consume_token(tPRINTLN);
    jj_consume_token(tLPARENTESIS);
    ListaPrintLn(block);
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tPCOMA);
}

// Lista en el println con comas
  static final public void ListaPrintLn(CodeBlock block) throws ParseException {Attributes a = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMAS:
    case tMENOS:
    case tNOT:
    case tTRUE:
    case tFALSE:
    case tLPARENTESIS:
    case tINT2CHAR:
    case tCHAR2INT:
    case tENTRECOMILLAS:
    case tENTRECOMILLASSIMPLES:
    case tID:
    case tDIGITO:{
      a = Expresion(block);
comprobarTipoValidoString(a);
                if (a.type == Symbol.Types.INT) {
                        block.addInst(OpCode.WRT, 1);
                } else if (a.type == Symbol.Types.BOOL) {
                        escribirBool(block);
                } else if (a.type == Symbol.Types.CHAR) {
                        block.addInst(OpCode.WRT, 0);
                } else if (a.type == Symbol.Types.STRING) {
                        // Hacer un bucle para recorrer todos los caracteres del string y almacenar su ascii
                        // en la pila
                        for (int i = 1; i < a.valString.length() - 1; i++) {
                                block.addInst(OpCode.STC, (int)a.valString.charAt(i));
                                block.addInst(OpCode.WRT, 0);
                        }
                }
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tCOMA:{
          ;
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          break label_18;
        }
        ListaPrint(block);
      }
comprobarTipoValidoString(a);
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      ;
    }
block.addInst(OpCode.STC, 10);
                block.addInst(OpCode.WRT, 0);
}

//----------------------   READ    ----------------------
  static final public void Read(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tREAD:{
      ReadN(block);
      break;
      }
    case tREADLN:{
      ReadLn(block);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

// Read normal
  static final public void ReadN(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol simbolo = null;
        boolean esVector = false;
        Symbol.Types a = null;
    jj_consume_token(tREAD);
    jj_consume_token(tLPARENTESIS);
    t = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLCORCHETE:{
      vector(block);
esVector = true;
      break;
      }
    default:
      jj_la1[37] = jj_gen;
      ;
    }
simbolo = tabla.getSymbol(t.image);
                block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
                // Si es por referencia, hacer un DRF
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
                if (esVector) {
                        if (simbolo instanceof SymbolArray) {
                                // Ver de que tipo es el vector
                                a = ((SymbolArray)simbolo).baseType;
                                comprobarTipoValido(a);
                                block.addInst(OpCode.PLUS);
                        }
                } else {
                        comprobarTipoValido(simbolo);
                        a = simbolo.type;
                }
                if (a == Symbol.Types.INT) {
                        block.addInst(OpCode.RD, 1);
                } else if (a == Symbol.Types.BOOL) {
                        block.addInst(OpCode.RD, 0);
                } else if (a == Symbol.Types.CHAR) {
                        block.addInst(OpCode.RD, 0);
                }
    ListaRead(block);
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tPCOMA);
}

// Lista en el read con comas
  static final public void ListaRead(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol simbolo = null;
        boolean esVector = false;
        Symbol.Types a = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tCOMA:{
      jj_consume_token(tCOMA);
      t = jj_consume_token(tID);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLCORCHETE:{
        vector(block);
esVector = true;
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      ListaRead(block);
simbolo = tabla.getSymbol(t.image); comprobarTipoValido(simbolo);
simbolo = tabla.getSymbol(t.image);
                block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
                // Si es por referencia, hacer un DRF
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
                if (esVector) {
                        if (simbolo instanceof SymbolArray) {
                                // Ver de que tipo es el vector
                                a = ((SymbolArray)simbolo).baseType;
                                comprobarTipoValido(a);
                        }
                } else {
                        comprobarTipoValido(simbolo);
                        a = simbolo.type;
                }
                if (a == Symbol.Types.INT) {
                        block.addInst(OpCode.RD, 1);
                } else if (a == Symbol.Types.BOOL) {
                        block.addInst(OpCode.RD, 0);
                } else if (a == Symbol.Types.CHAR) {
                        block.addInst(OpCode.RD, 0);
                }
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      ;
    }
}

// ReadLn
  static final public void ReadLn(CodeBlock block) throws ParseException {
    jj_consume_token(tREADLN);
    jj_consume_token(tLPARENTESIS);
    ListaReadLn(block);
    jj_consume_token(tRPARENTESIS);
    jj_consume_token(tPCOMA);
}

// Lista en el ReadLn con comas
  static final public void ListaReadLn(CodeBlock block) throws ParseException {Token t = new Token();
        Symbol simbolo = null;
        boolean esVector = false;
        Symbol.Types a = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tID:{
      t = jj_consume_token(tID);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLCORCHETE:{
        vector(block);
esVector = true;
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        ;
      }
simbolo = tabla.getSymbol(t.image);
                block.addInst(OpCode.SRF, tabla.level - simbolo.nivel, simbolo.posicionPila);
                // Si es por referencia, hacer un DRF
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
                if (esVector) {
                        if (simbolo instanceof SymbolArray) {
                                // Ver de que tipo es el vector
                                a = ((SymbolArray)simbolo).baseType;
                                comprobarTipoValido(a);
                                block.addInst(OpCode.PLUS);
                        }
                } else {
                        comprobarTipoValido(simbolo);
                        a = simbolo.type;
                }
                if (a == Symbol.Types.INT) {
                        block.addInst(OpCode.RD, 1);
                } else if (a == Symbol.Types.BOOL) {
                        block.addInst(OpCode.RD, 0);
                } else if (a == Symbol.Types.CHAR) {
                        block.addInst(OpCode.RD, 0);
                }
      ListaRead(block);
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      ;
    }
}

//----------------------   EXPRESION    ----------------------
// TODO: Añadir un campo const que sea booleano y cuando varias sean constantes, 
// se pueda hacer la operacion
  static final public Attributes Expresion(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
    a = Relacion(block);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tOR:
    case tAND:{
      b = Mas_relation(block);
{if ("" != null) return comprobarTipos(a,b);}
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
{if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public Attributes Mas_relation(CodeBlock block) throws ParseException {Attributes a;
        int op;
    label_19:
    while (true) {
      op = And_or(block);
      a = Relacion(block);
comprobarBool(a);
                if (op == 1) {
                        block.addInst(OpCode.OR);
                } else if (op == 2) {
                        block.addInst(OpCode.AND);
                }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tOR:
      case tAND:{
        ;
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        break label_19;
      }
    }
{if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public int And_or(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tOR:{
      jj_consume_token(tOR);
{if ("" != null) return 1;}
      break;
      }
    case tAND:{
      jj_consume_token(tAND);
{if ("" != null) return 2;}
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Attributes Relacion(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
        int op;
    a = Expresion_simple(block);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tDOBLEIGUAL:
    case tMAYOR:
    case tMENOR:
    case tMAYORIGUAL:
    case tMENORIGUAL:
    case tDIFERENTE:{
      op = Operador_relacional(block);
      b = Expresion_simple(block);
// Aplicar la operacion
                        if (op == 1) {
                                block.addInst(OpCode.EQ);
                        } else if (op == 2) {
                                block.addInst(OpCode.LT);
                        } else if (op == 3) {
                                block.addInst(OpCode.GT);
                        } else if (op == 4) {
                                block.addInst(OpCode.LTE);
                        } else if (op == 5) {
                                block.addInst(OpCode.GTE);
                        } else {
                                block.addInst(OpCode.NEQ);
                        }
                        comprobarTipos(a,b); {if ("" != null) return new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,null);}
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
{if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public int Operador_relacional(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tDOBLEIGUAL:{
      jj_consume_token(tDOBLEIGUAL);
{if ("" != null) return 1;}
      break;
      }
    case tMENOR:{
      jj_consume_token(tMENOR);
{if ("" != null) return 2;}
      break;
      }
    case tMAYOR:{
      jj_consume_token(tMAYOR);
{if ("" != null) return 3;}
      break;
      }
    case tMENORIGUAL:{
      jj_consume_token(tMENORIGUAL);
{if ("" != null) return 4;}
      break;
      }
    case tMAYORIGUAL:{
      jj_consume_token(tMAYORIGUAL);
{if ("" != null) return 5;}
      break;
      }
    case tDIFERENTE:{
      jj_consume_token(tDIFERENTE);
{if ("" != null) return 6;}
      break;
      }
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Attributes Expresion_simple(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
        boolean esEntero = false;
        int o = 0;
        int op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMAS:
    case tMENOS:{
      o = Op_MAS_MENOS(block);
esEntero = true;
      break;
      }
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    a = Termino(block);
if (o == 2) {
                        // Negar el termino
                        block.addInst(OpCode.NGI);
                }
    label_20:
    while (true) {
      if (jj_2_9(2)) {
        ;
      } else {
        break label_20;
      }
      op = Op_MAS_MENOS(block);
      b = Termino(block);
comprobarInt(b);
                    esEntero = true;

                        // Aplicar la operacion
                        if (op == 1) {
                                block.addInst(OpCode.PLUS);
                        } else {
                                block.addInst(OpCode.SBT);
                        }
    }
if (esEntero) {
                        // Si se utiliza el operador '+' o '-', verificar que es del tipo int
                        comprobarInt(a);
                }
                {if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public int Op_MAS_MENOS(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMAS:{
      jj_consume_token(tMAS);
{if ("" != null) return 1;}
      break;
      }
    case tMENOS:{
      jj_consume_token(tMENOS);
{if ("" != null) return 2;}
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Attributes Termino(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
        boolean esEntero = false;
        int op;
    a = Factor(block);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMULTIPLICACION:
      case tDIVISION:
      case tMODULO:{
        ;
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        break label_21;
      }
      op = Op_MULT(block);
      b = Factor(block);
comprobarInt(b);
                        esEntero = true;

                        if (op == 1) {
                                block.addInst(OpCode.TMS);
                        } else if (op == 2) {
                                block.addInst(OpCode.DIV);
                        } else {
                                block.addInst(OpCode.MOD);
                        }
    }
if (esEntero) {
                        // Si se utiliza el operador '*' o '/' o '%', verificar que es del tipo int
                        comprobarInt(a);
                }
                {if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public int Op_MULT(CodeBlock block) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMULTIPLICACION:{
      jj_consume_token(tMULTIPLICACION);
{if ("" != null) return 1;}
      break;
      }
    case tDIVISION:{
      jj_consume_token(tDIVISION);
{if ("" != null) return 2;}
      break;
      }
    case tMODULO:{
      jj_consume_token(tMODULO);
{if ("" != null) return 3;}
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Attributes Factor(CodeBlock block) throws ParseException {Attributes a;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tTRUE:
    case tFALSE:
    case tLPARENTESIS:
    case tINT2CHAR:
    case tCHAR2INT:
    case tENTRECOMILLAS:
    case tENTRECOMILLASSIMPLES:
    case tID:
    case tDIGITO:{
      a = Primario(block);
{if ("" != null) return a;}
      break;
      }
    case tNOT:{
      jj_consume_token(tNOT);
      a = Primario(block);
comprobarBool(a); block.addInst(OpCode.NGB);
{if ("" != null) return a;}
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static final public Attributes Primario(CodeBlock block) throws ParseException {Attributes atributo = null;
        Symbol.Types a = null;
        Token t = new Token();
        Symbol simbolo = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPARENTESIS:{
      jj_consume_token(tLPARENTESIS);
      atributo = Expresion(block);
      jj_consume_token(tRPARENTESIS);
{if ("" != null) return atributo;}
      break;
      }
    case tINT2CHAR:{
      jj_consume_token(tINT2CHAR);
      jj_consume_token(tLPARENTESIS);
      atributo = Expresion(block);
      jj_consume_token(tRPARENTESIS);
// Verificar que la expresion es un entero
                comprobarInt(atributo);
                {if ("" != null) return new Attributes(Symbol.Types.CHAR,Symbol.ParameterClass.NONE,null);}
      break;
      }
    case tCHAR2INT:{
      jj_consume_token(tCHAR2INT);
      jj_consume_token(tLPARENTESIS);
      atributo = Expresion(block);
      jj_consume_token(tRPARENTESIS);
// Verificar que la expresion es un entero
                comprobarChar(atributo);
                {if ("" != null) return new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,null);}
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      if (jj_2_10(2)) {
        t = jj_consume_token(tID);
simbolo = tabla.getSymbol(t.image);
                block.addComment("Val(" + simbolo.name + ")");
                block.addInst(OpCode.SRF, tabla.level - simbolo.nivel,simbolo.posicionPila);
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
        jj_consume_token(tLCORCHETE);
        atributo = Expresion(block);
        jj_consume_token(tRCORCHETE);
comprobarInt(atributo);
                block.addInst(OpCode.PLUS);
                block.addInst(OpCode.DRF);
                simbolo = tabla.getSymbol(t.image);
                if (simbolo instanceof SymbolArray) {
                        a = ((SymbolArray)simbolo).baseType;
                }
                {if ("" != null) return new Attributes(a,simbolo.parClass,atributo.valInt);}
      } else if (jj_2_11(2)) {
        atributo = LlamaFunc(block);
{if ("" != null) return atributo;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tID:{
          t = jj_consume_token(tID);
// Caso de una variable
                simbolo = tabla.getSymbol(t.image);
                block.addComment("Val(" + simbolo.name + ")");
                block.addInst(OpCode.SRF, tabla.level - simbolo.nivel,simbolo.posicionPila);
                block.addInst(OpCode.DRF);
                if (simbolo.parClass == Symbol.ParameterClass.REF) {
                        block.addInst(OpCode.DRF);
                }
                atributo = new Attributes(simbolo.type,simbolo.parClass,t.image);
                {if ("" != null) return atributo;}
          break;
          }
        case tDIGITO:{
          t = jj_consume_token(tDIGITO);
block.addComment("Constante entera igual a " + t.image);
                int valor = Integer.parseInt(t.image);
                block.addInst(OpCode.STC,valor);
                {if ("" != null) return new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,valor);}
          break;
          }
        case tTRUE:{
          t = jj_consume_token(tTRUE);
block.addComment("Constante true");
                block.addInst(OpCode.STC,1);
                {if ("" != null) return new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,true);}
          break;
          }
        case tFALSE:{
          t = jj_consume_token(tFALSE);
block.addComment("Constante false");
                block.addInst(OpCode.STC,0);
                {if ("" != null) return new Attributes(Symbol.Types.BOOL,Symbol.ParameterClass.NONE,false);}
          break;
          }
        case tENTRECOMILLAS:{
          t = jj_consume_token(tENTRECOMILLAS);
// Calcular el ascii del caracter

                {if ("" != null) return devolverAtributo(Symbol.Types.STRING,t);}
          break;
          }
        case tENTRECOMILLASSIMPLES:{
          t = jj_consume_token(tENTRECOMILLASSIMPLES);
block.addComment("Constante char");
                block.addInst(OpCode.STC,(int)t.image.charAt(1));
                {if ("" != null) return new Attributes(Symbol.Types.CHAR,Symbol.ParameterClass.NONE,t.image);}
          break;
          }
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
}

//----------------------   EXPRESION DE CONSTANTES   ----------------------
  static final public 
Attributes Expresion_simple_const(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
        boolean esEntero = false;
        int operacion;
        int operacion2 = 0;
        int resultado;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMAS:
    case tMENOS:{
      operacion2 = Op_MAS_MENOS(block);
esEntero = true;
      break;
      }
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    a = Termino_const(block);
if (esEntero) {
                        if (operacion2 == 2) {
                                resultado = -a.valInt;
                        } else {
                                resultado = a.valInt;
                        }
                } else {
                        resultado = a.valInt;
                }
    label_22:
    while (true) {
      if (jj_2_12(2)) {
        ;
      } else {
        break label_22;
      }
      operacion = Op_MAS_MENOS(block);
      b = Termino_const(block);
comprobarInt(b);
                    esEntero = true;
                        if (operacion == 2) {
                                resultado = resultado - b.valInt;
                        } else {
                                resultado = resultado + b.valInt;
                        }
    }
if (esEntero) {
                        // Si se utiliza el operador '+' o '-', verificar que es del tipo int
                        comprobarInt(a);
                        a.valInt = resultado;
                        block.addInst(OpCode.STC, resultado);
                }
                {if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public Attributes Termino_const(CodeBlock block) throws ParseException {Attributes a;
        Attributes b;
        boolean esEntero = false;
        int resultado;
        int operacion;
    a = Primario_const(block);
resultado = a.valInt;
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMULTIPLICACION:
      case tDIVISION:
      case tMODULO:{
        ;
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        break label_23;
      }
      operacion = Op_MULT(block);
      b = Primario_const(block);
comprobarInt(b);
                        esEntero = true;
                        switch(operacion){
                                case 1:
                                        // multiplicacion
                                        resultado = resultado * b.valInt;
                                        break;
                                case 2:
                                        // Division
                                        resultado = resultado / b.valInt;
                                        break;
                                case 3:
                                        // Modulo
                                        resultado = resultado % b.valInt;
                                        break;
                        }
    }
if (esEntero) {
                        // Si se utiliza el operador '*' o '/' o '%', verificar que es del tipo int
                        comprobarInt(a);
                }
                a.valInt = resultado;
                {if ("" != null) return a;}
    throw new Error("Missing return statement in function");
}

  static final public Attributes Primario_const(CodeBlock block) throws ParseException {Attributes atributo = null;
        Token t = new Token();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPARENTESIS:{
      jj_consume_token(tLPARENTESIS);
      atributo = Expresion_simple_const(block);
      jj_consume_token(tRPARENTESIS);
{if ("" != null) return atributo;}
      break;
      }
    case tDIGITO:{
      t = jj_consume_token(tDIGITO);
{if ("" != null) return new Attributes(Symbol.Types.INT,Symbol.ParameterClass.NONE,Integer.parseInt(t.image));}
      break;
      }
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_3R_Factor_1605_9_47()
 {
    if (jj_3R_Primario_1617_17_53()) return true;
    return false;
  }

  static private boolean jj_3R_Factor_1605_9_39()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Factor_1605_9_47()) {
    jj_scanpos = xsp;
    if (jj_3R_Factor_1606_9_48()) return true;
    }
    return false;
  }

  static private boolean jj_3R_Primario_1690_17_64()
 {
    if (jj_scan_token(tENTRECOMILLASSIMPLES)) return true;
    return false;
  }

  static private boolean jj_3R_FuncYDeclaracion_462_9_33()
 {
    if (jj_3R_Funcs_467_9_41()) return true;
    return false;
  }

  static private boolean jj_3R_FuncYDeclaracion_461_9_24()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_FuncYDeclaracion_462_9_33()) return true;
    }
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_3R_Def_909_9_25()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1684_17_63()
 {
    if (jj_scan_token(tENTRECOMILLAS)) return true;
    return false;
  }

  static private boolean jj_3R_Asig_1024_9_26()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) return true;
    }
    return false;
  }

  static private boolean jj_3_7()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tIGUAL)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1678_17_62()
 {
    if (jj_scan_token(tFALSE)) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    if (jj_3R_FuncYDeclaracion_461_9_24()) return true;
    return false;
  }

  static private boolean jj_3R_LlamaFuncYProced_828_9_27()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3R_Def_913_17_35()
 {
    if (jj_3R_vector_const_702_9_45()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1672_17_61()
 {
    if (jj_scan_token(tTRUE)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1665_17_60()
 {
    if (jj_scan_token(tDIGITO)) return true;
    return false;
  }

  static private boolean jj_3R_Def_909_9_25()
 {
    if (jj_3R_TipoVal_488_5_34()) return true;
    if (jj_scan_token(tID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Def_913_17_35()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_Def_954_18_36()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(tPCOMA)) return true;
    return false;
  }

  static private boolean jj_3R_Termino_const_1758_9_32()
 {
    if (jj_3R_Primario_const_1796_17_40()) return true;
    return false;
  }

  static private boolean jj_3R_Termino_1567_9_30()
 {
    if (jj_3R_Factor_1605_9_39()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1652_17_59()
 {
    if (jj_scan_token(tID)) return true;
    return false;
  }

  static private boolean jj_3_11()
 {
    if (jj_3R_LlamaFunc_796_9_31()) return true;
    return false;
  }

  static private boolean jj_3R_vector_const_702_9_45()
 {
    if (jj_scan_token(tLCORCHETE)) return true;
    return false;
  }

  static private boolean jj_3R_Op_MAS_MENOS_1557_9_38()
 {
    if (jj_scan_token(tMENOS)) return true;
    return false;
  }

  static private boolean jj_3R_LlamaFunc_796_9_31()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3R_Op_MAS_MENOS_1556_9_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Op_MAS_MENOS_1556_9_37()) {
    jj_scanpos = xsp;
    if (jj_3R_Op_MAS_MENOS_1557_9_38()) return true;
    }
    return false;
  }

  static private boolean jj_3R_Op_MAS_MENOS_1556_9_37()
 {
    if (jj_scan_token(tMAS)) return true;
    return false;
  }

  static private boolean jj_3R_Func_502_9_54()
 {
    if (jj_3R_TipoVal_488_5_34()) return true;
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3_12()
 {
    if (jj_3R_Op_MAS_MENOS_1556_9_29()) return true;
    if (jj_3R_Termino_const_1758_9_32()) return true;
    return false;
  }

  static private boolean jj_3_10()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLCORCHETE)) return true;
    return false;
  }

  static private boolean jj_3_6()
 {
    if (jj_3R_LlamaFuncYProced_828_9_27()) return true;
    return false;
  }

  static private boolean jj_3R_vector_686_9_28()
 {
    if (jj_scan_token(tLCORCHETE)) return true;
    return false;
  }

  static private boolean jj_3_9()
 {
    if (jj_3R_Op_MAS_MENOS_1556_9_29()) return true;
    if (jj_3R_Termino_1567_9_30()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1624_17_58()
 {
    if (jj_scan_token(tCHAR2INT)) return true;
    return false;
  }

  static private boolean jj_3_5()
 {
    if (jj_3R_Asig_1024_9_26()) return true;
    return false;
  }

  static private boolean jj_3R_Vars_966_9_46()
 {
    if (jj_scan_token(tCOMA)) return true;
    return false;
  }

  static private boolean jj_3R_Def_954_18_36()
 {
    if (jj_3R_Vars_966_9_46()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1618_17_57()
 {
    if (jj_scan_token(tINT2CHAR)) return true;
    return false;
  }

  static private boolean jj_3R_TipoVal_490_5_44()
 {
    if (jj_scan_token(tBOOL)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1617_17_56()
 {
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_1617_17_53()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Primario_1617_17_56()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1618_17_57()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1624_17_58()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1652_17_59()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1665_17_60()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1672_17_61()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1678_17_62()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1684_17_63()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_1690_17_64()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_TipoVal_489_5_43()
 {
    if (jj_scan_token(tCHAR)) return true;
    return false;
  }

  static private boolean jj_3_4()
 {
    if (jj_3R_LlamaFuncYProced_828_9_27()) return true;
    return false;
  }

  static private boolean jj_3R_TipoVal_488_5_34()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_TipoVal_488_5_42()) {
    jj_scanpos = xsp;
    if (jj_3R_TipoVal_489_5_43()) {
    jj_scanpos = xsp;
    if (jj_3R_TipoVal_490_5_44()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_TipoVal_488_5_42()
 {
    if (jj_scan_token(tINT)) return true;
    return false;
  }

  static private boolean jj_3_3()
 {
    if (jj_3R_Asig_1024_9_26()) return true;
    return false;
  }

  static private boolean jj_3R_Primario_const_1797_17_50()
 {
    if (jj_scan_token(tDIGITO)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_const_1796_17_49()
 {
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3R_Primario_const_1796_17_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Primario_const_1796_17_49()) {
    jj_scanpos = xsp;
    if (jj_3R_Primario_const_1797_17_50()) return true;
    }
    return false;
  }

  static private boolean jj_3R_Proced_568_9_55()
 {
    if (jj_scan_token(tVOID)) return true;
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPARENTESIS)) return true;
    return false;
  }

  static private boolean jj_3_8()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_3R_vector_686_9_28()) return true;
    return false;
  }

  static private boolean jj_3R_Funcs_468_9_52()
 {
    if (jj_3R_Proced_568_9_55()) return true;
    return false;
  }

  static private boolean jj_3R_Funcs_467_9_51()
 {
    if (jj_3R_Func_502_9_54()) return true;
    return false;
  }

  static private boolean jj_3R_Funcs_467_9_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Funcs_467_9_51()) {
    jj_scanpos = xsp;
    if (jj_3R_Funcs_468_9_52()) return true;
    }
    return false;
  }

  static private boolean jj_3R_Factor_1606_9_48()
 {
    if (jj_scan_token(tNOT)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public clike_4TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[57];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xf00,0xf00,0x700,0x80000000,0x700,0x700,0x700,0x80000000,0x700,0x700,0x80000000,0x1000000,0x0,0x40000,0x1000000,0x0,0x80000000,0x0,0x80000000,0x2620c000,0x40000,0x0,0x40000,0x0,0x80000000,0x0,0x80000000,0x80000000,0x80000000,0x0,0x80000000,0x80000000,0x0,0x40000,0x40000,0x2620c000,0x0,0x0,0x0,0x40000,0x0,0x0,0xc00000,0xc00000,0xc00000,0x8000000,0x8000000,0xc000,0xc000,0x30000,0x30000,0x26200000,0x20000000,0x6000000,0xc000,0x30000,0x20000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x80003e,0x0,0x0,0x0,0x80203e,0x0,0x0,0x80003e,0x0,0x800,0x0,0x0,0x800,0x3e,0x2000,0x3e,0x1e000c0,0x0,0x800,0x0,0x800,0x80203e,0x1,0x80003e,0x80203e,0x80003e,0x1,0x80203e,0x80003e,0x30,0x0,0x0,0x1e000c0,0xc,0x800,0x800,0x0,0x800,0x800000,0x0,0x0,0x0,0xf8000,0xf8000,0x0,0x0,0x100000,0x100000,0x1e000c0,0xc0,0x1e00000,0x0,0x100000,0x1000000,};
	}
  static final private JJCalls[] jj_2_rtns = new JJCalls[12];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public clike_4(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public clike_4(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new clike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public clike_4(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new clike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new clike_4TokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public clike_4(clike_4TokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(clike_4TokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 57; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[59];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 57; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 59; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 12; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
